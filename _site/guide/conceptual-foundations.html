<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/assets/css/just-the-docs-default.css"> <link rel="stylesheet" href="/assets/css/just-the-docs-head-nav.css" id="jtd-head-nav-stylesheet"> <style id="jtd-nav-activation"> .site-nav > ul.nav-list:first-child > li:not(:nth-child(2)) > a, .site-nav > ul.nav-list:first-child > li > ul > li a { background-image: none; } .site-nav > ul.nav-list:not(:first-child) a, .site-nav li.external a { background-image: none; } .site-nav > ul.nav-list:first-child > li:nth-child(2) > a { font-weight: 600; text-decoration: none; }.site-nav > ul.nav-list:first-child > li:nth-child(2) > button svg { transform: rotate(-90deg); }.site-nav > ul.nav-list:first-child > li.nav-list-item:nth-child(2) > ul.nav-list { display: block; } </style> <script src="/assets/js/vendor/lunr.min.js"></script> <script src="/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>Conceptual Foundations | UbiSpec</title> <meta name="generator" content="Jekyll v4.4.1" /> <meta property="og:title" content="Conceptual Foundations" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Behavioural Specification Format for Software Systems" /> <meta property="og:description" content="Behavioural Specification Format for Software Systems" /> <link rel="canonical" href="http://0.0.0.0:4000/guide/conceptual-foundations.html" /> <meta property="og:url" content="http://0.0.0.0:4000/guide/conceptual-foundations.html" /> <meta property="og:site_name" content="UbiSpec" /> <meta property="og:type" content="website" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Conceptual Foundations" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","description":"Behavioural Specification Format for Software Systems","headline":"Conceptual Foundations","url":"http://0.0.0.0:4000/guide/conceptual-foundations.html"}</script> <!-- End Jekyll SEO tag --> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" class="d-none"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <!-- Bootstrap Icons. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md --> <symbol id="svg-copy" viewBox="0 0 16 16"> <title>Copy</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16"> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/> <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/> </svg> </symbol> <symbol id="svg-copied" viewBox="0 0 16 16"> <title>Copied</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16"> <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/> </svg> </symbol> </svg> <header class="side-bar"> <div class="site-header"> <a href="/" class="site-title lh-tight"> UbiSpec </a> <button id="menu-button" class="site-button btn-reset" aria-label="Menu" aria-expanded="false"> <svg viewBox="0 0 24 24" class="icon" aria-hidden="true"><use xlink:href="#svg-menu"></use></svg> </button> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-list-link">Home</a></li><li class="nav-list-item"><a href="/guide/conceptual-foundations.html" class="nav-list-link">Conceptual Foundations</a></li><li class="nav-list-item"><a href="/guide/getting-started.html" class="nav-list-link">Getting Started</a></li><li class="nav-list-item"><a href="/guide/guide.html" class="nav-list-link">Guide</a></li><li class="nav-list-item"><a href="/spec/lifecycle.html" class="nav-list-link">Lifecycle UbiSpec</a></li><li class="nav-list-item"><a href="/spec/process.html" class="nav-list-link">Process UbiSpec</a></li><li class="nav-list-item"><a href="/examples/" class="nav-list-link">Examples</a></li><li class="nav-list-item"><a href="/guide/example-artifacts.html" class="nav-list-link">Example artifacts</a></li></ul> <ul class="nav-list"><li class="nav-list-item external"> <a href="https://github.com/mean-machine-gc/bspec" class="nav-list-link external" > GitHub <svg viewBox="0 0 24 24" aria-labelledby="svg-external-link-title"><use xlink:href="#svg-external-link"></use></svg> </a> </li></ul> </nav> <div class="d-md-block d-none site-footer"> This site uses <a href="https://github.com/just-the-docs/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </div> </header> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search" role="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search UbiSpec" autocomplete="off"> <label for="search-input" class="search-label"> <span class="sr-only">Search UbiSpec</span> <svg viewBox="0 0 24 24" class="search-icon" aria-hidden="true"><use xlink:href="#svg-search"></use></svg> </label> </div> <div id="search-results" class="search-results"></div> </div> <nav aria-label="Auxiliary" class="aux-nav"> <ul class="aux-nav-list"> <li class="aux-nav-list-item"> <a href="https://github.com/mean-machine-gc/bspec" class="site-button" > GitHub </a> </li> </ul> </nav> </div> <div class="main-content-wrap"> <div id="main-content" class="main-content"> <main> <h1 id="conceptual-foundations"> <a href="#conceptual-foundations" class="anchor-heading" aria-labelledby="conceptual-foundations"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Conceptual Foundations </h1> <p>This page explains the reasoning behind UbiSpec: where the format comes from, why it takes the shape it does, and how each design choice follows from the one before it.</p> <h2 id="starting-point-eventstormings-visual-grammar"> <a href="#starting-point-eventstormings-visual-grammar" class="anchor-heading" aria-labelledby="starting-point-eventstormings-visual-grammar"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Starting Point: EventStorming’s Visual Grammar </h2> <p>UbiSpec owes its primary debt to <a href="https://www.eventstorming.com/">EventStorming</a>, created by Alberto Brandolini. EventStorming provides a visual grammar for exploring system behaviour using sticky notes — commands, events, policies, aggregates, read models — that a room full of people can arrange on a wall to build a shared understanding of a domain.</p> <p>What makes EventStorming powerful is not the sticky notes. It is the <strong>two fundamental sequences</strong> that compose all system behaviour:</p> <p><strong>The command-led sequence.</strong> A user (or system) issues a command. The command is evaluated against the current state. If accepted, one or more events are produced. These events represent what happened — facts about the system’s history.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Command → [conditions] → Event(s)
</code></pre></div></div> <p><strong>The policy sequence.</strong> An event is observed. A policy decides whether and how to react. If it reacts, it issues one or more commands, which feed into other command-led sequences.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Event(s) → [policy logic] → Command(s)
</code></pre></div></div> <p>These two sequences compose. A command produces events, which trigger policies, which issue commands, which produce events. Any system behaviour — however complex — can be decomposed into these two building blocks chained together.</p> <p>UbiSpec formalises these two sequences into two specification formats:</p> <div class="table-wrapper"><table> <thead> <tr> <th>EventStorming</th> <th>UbiSpec</th> <th>File</th> </tr> </thead> <tbody> <tr> <td>Command-led sequence</td> <td><strong>Decision</strong></td> <td>Lifecycle UbiSpec</td> </tr> <tr> <td>Policy sequence</td> <td><strong>Reaction</strong></td> <td>Process UbiSpec</td> </tr> </tbody> </table></div> <p>The entire format follows from this decomposition.</p> <h2 id="decisions-the-structure-of-a-command-led-sequence"> <a href="#decisions-the-structure-of-a-command-led-sequence" class="anchor-heading" aria-labelledby="decisions-the-structure-of-a-command-led-sequence"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Decisions: The Structure of a Command-Led Sequence </h2> <p>A decision is what happens when a command arrives. If we dissect a decision carefully, an intrinsic logical structure emerges that can explain all possible configurations.</p> <p><strong>A command produces one or more events if some conditions are met.</strong> These conditions are constraints — business rules, state guards, authorisation checks, validation rules. They must all hold for the command to succeed.</p> <p><strong>If any constraint fails, the result is a domain failure.</strong> The command was attempted but could not proceed. The failure is directly linked to the constraints that were not satisfied.</p> <p><strong>If we abstract the failure by convention</strong> — by saying that a failed constraint always produces a standard <code class="language-plaintext highlighter-rouge">DecisionFailed</code> event carrying the names of the constraints that failed — then we can focus the specification entirely on the success path. The failure scenarios are implicit: for each constraint, there is a failure scenario where it is violated. The constraint names become the failure reasons. No separate failure specification is needed.</p> <p>This is not a simplification for convenience. It is a design principle: the specification describes <strong>what the system can do</strong>, not all the ways it can refuse. The refusal cases are mechanically derivable from the success cases.</p> <p><strong>But not all events are always emitted on success.</strong> Some events are conditional — they depend on additional branching logic beyond the entry constraints. An order approval might always produce an <code class="language-plaintext highlighter-rouge">OrderApproved</code> event, but only produce an <code class="language-plaintext highlighter-rouge">ArchivalTriggered</code> event when a previous active version exists.</p> <p>So a decision has four elements:</p> <ol> <li><strong>Command</strong> — the trigger</li> <li><strong>Constraints</strong> — what must hold for the command to succeed</li> <li><strong>Events</strong> — what is produced on success, some unconditional, some conditional</li> <li><strong>Branching logic</strong> — conditions determining which conditional events fire</li> </ol> <p>This accounts for every configuration a command-led sequence can take.</p> <h2 id="the-decision-model-what-data-does-a-decision-need"> <a href="#the-decision-model-what-data-does-a-decision-need" class="anchor-heading" aria-labelledby="the-decision-model-what-data-does-a-decision-need"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> The Decision Model: What Data Does a Decision Need? </h2> <p>To evaluate constraints and branching logic, the decision needs data. If we ask <em>what data?</em> systematically, three distinct sources emerge:</p> <p><strong>The command itself (<code class="language-plaintext highlighter-rouge">dm.cmd</code>).</strong> The command carries the user’s intent and any request metadata — the payload they submitted. “Approve this registry. Here is my reviewer ID and the effective date.”</p> <p><strong>The current state of the aggregate (<code class="language-plaintext highlighter-rouge">dm.state</code>).</strong> The system’s current knowledge about this entity — its status, its contents, its history of changes. “The registry is in Submitted status. It has three profiles.”</p> <p><strong>External context (<code class="language-plaintext highlighter-rouge">dm.ctx</code>).</strong> Information that lives outside the aggregate — in another service, in a clock, in a read model. The aggregate can’t know this from its own history; something must look it up before the decision runs. “Is this reviewer authorised? Is another registry currently active?”</p> <p>These three sources — command, state, context — are the <strong>decision model</strong>. In UbiSpec, they form the <code class="language-plaintext highlighter-rouge">dm</code> namespace: <code class="language-plaintext highlighter-rouge">dm.cmd</code>, <code class="language-plaintext highlighter-rouge">dm.state</code>, <code class="language-plaintext highlighter-rouge">dm.ctx</code>.</p> <p>The context namespace does quiet but important work. Every <code class="language-plaintext highlighter-rouge">dm.ctx</code> reference in a specification is a <strong>shell contract</strong>: a declaration that the runtime environment must resolve this value before the decision function is called. An agent or developer can scan a specification for all <code class="language-plaintext highlighter-rouge">dm.ctx</code> references and mechanically derive the integration points for each command. Nothing is hidden.</p> <p>The three-namespace structure also makes the <strong>purity boundary</strong> explicit. <code class="language-plaintext highlighter-rouge">dm.cmd</code> and <code class="language-plaintext highlighter-rouge">dm.state</code> are synchronous and deterministic — they are values already available. <code class="language-plaintext highlighter-rouge">dm.ctx</code> is the seam where the outside world enters. The decision function itself is pure: given (cmd, state, ctx), it produces the same events every time. The impurity is isolated in the shell that resolves the context before the decision runs.</p> <h2 id="events-and-state-what-changes"> <a href="#events-and-state-what-changes" class="anchor-heading" aria-labelledby="events-and-state-what-changes"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Events and State: What Changes? </h2> <p>A decision produces events. But what are events? Do they represent a change in state, or do they trigger a change in state?</p> <p>This is where the work of Jérémie Chassaing on the <strong>Decider pattern</strong> becomes foundational. Chassaing formalised a functional representation of an event-sourced aggregate as three elements:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>decide:  (command, state) → event[]
evolve:  (state, event) → state
initial: state
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">decide</code> function makes the decision — given a command and the current state, what events are produced? The <code class="language-plaintext highlighter-rouge">evolve</code> function applies an event to a state, producing the new state. The <code class="language-plaintext highlighter-rouge">initial</code> value is the starting state before any events have occurred.</p> <p>State is derived by folding events: <code class="language-plaintext highlighter-rouge">state = events.reduce(evolve, initial)</code>. The events are the source of truth. State is a computation over them.</p> <p>This separation offers several practical advantages:</p> <p><strong>Auditability.</strong> The event stream is a complete record of what happened and why. State is a projection — a view derived from history. You can always explain how the system arrived at its current state by replaying the events.</p> <p><strong>Testability.</strong> The decide function is pure: same inputs, same outputs. No side effects, no database calls, no external dependencies (those are resolved in the context before decide runs). This makes property-based testing natural: for any valid combination of command, state, and context, assert that the produced events satisfy the specification.</p> <p><strong>Composability.</strong> Multiple views (read models, projections, analytics) can be derived from the same event stream. Each view folds the events differently. The events are shared; the interpretations are independent.</p> <p><strong>Separation of concerns.</strong> The decision logic (what events to produce) is separate from the state transition logic (how to apply an event). This prevents a common mistake: mixing business rule validation with state mutation, which makes both harder to reason about and test.</p> <p>UbiSpec captures the decide side of this pattern — what events a command produces under what conditions. The evolve side is implied by the outcome assertions: “after these events are applied, these things must be true about the state.” The Lifecycle UbiSpec is, in essence, a formal contract for both sides of the Decider pattern.</p> <p>It is worth noting that event sourcing is a natural fit for this model but not a requirement. The decision/reaction decomposition, the namespace model, and the specification structure all work regardless of how state is persisted. A system using traditional state storage can still benefit from specifying behaviour as decisions and reactions with clear input and output models.</p> <h2 id="the-outcome-model-verifying-what-happened"> <a href="#the-outcome-model-verifying-what-happened" class="anchor-heading" aria-labelledby="the-outcome-model-verifying-what-happened"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> The Outcome Model: Verifying What Happened </h2> <p>A decision produces events. Events are applied to state via evolve. But how do we verify that the right thing happened?</p> <p>The outcome model (<code class="language-plaintext highlighter-rouge">om</code>) provides the verification context. After all events have been applied, the outcome model exposes:</p> <p><strong><code class="language-plaintext highlighter-rouge">om.state</code></strong> — the new state after evolve. This is where we assert what changed: “the registry is now Active”, “the line item is in the catalog.”</p> <p><strong><code class="language-plaintext highlighter-rouge">om.evts</code></strong> — the events that were emitted. This is where we assert what happened: “a RegistryApproved event was produced”, “the event carries the correct effective date.”</p> <p>Crucially, outcome assertions also have access to the decision model — <code class="language-plaintext highlighter-rouge">dm.state</code> (the state before), <code class="language-plaintext highlighter-rouge">dm.cmd</code> (the original command), and <code class="language-plaintext highlighter-rouge">dm.ctx</code> (the resolved context). This enables three essential categories of assertion:</p> <p><strong>Positive assertions.</strong> What changed. “State is Active. Effective date is set.”</p> <p><strong>Negative assertions.</strong> What must not change. “The test catalog is unchanged. Other assignments are preserved.” These catch accidental side effects — an evolve function that inadvertently clears unrelated state would fail a negative assertion even if all positive assertions pass.</p> <p><strong>Data flow assertions.</strong> The outputs carry the right data from the inputs. “The event’s effective date matches the command’s effective date. The archival event targets the correct registry ID from the context.” These verify that information flows correctly through the decision without being lost or garbled.</p> <p>The outcome model closes the specification loop. The decision model defines what goes in. The constraints and event conditions define the logic. The outcome model defines what must come out. Together, they form a complete behavioural contract that can be verified mechanically — as a test suite, as a property-based test, or as a runtime assertion.</p> <h2 id="reactions-the-structure-of-a-policy-sequence"> <a href="#reactions-the-structure-of-a-policy-sequence" class="anchor-heading" aria-labelledby="reactions-the-structure-of-a-policy-sequence"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Reactions: The Structure of a Policy Sequence </h2> <p>Where a decision transforms commands into events within one aggregate, a reaction coordinates between aggregates. An event on one aggregate triggers commands on another.</p> <p>The reaction model (<code class="language-plaintext highlighter-rouge">rm</code>) mirrors the decision model, but the inputs are different:</p> <p><strong><code class="language-plaintext highlighter-rouge">rm.event</code></strong> — the triggering event, analogous to <code class="language-plaintext highlighter-rouge">dm.cmd</code>. Where a decision is triggered by a user’s intent (a command), a reaction is triggered by a fact about what happened (an event).</p> <p><strong><code class="language-plaintext highlighter-rouge">rm.state</code></strong> — the process manager’s own state, if it is stateful. Most reactions are stateless — they receive an event and immediately determine what commands to dispatch. Stateful reactions (sagas) track progress across multiple events, for example waiting for several confirmations before proceeding.</p> <p><strong><code class="language-plaintext highlighter-rouge">rm.ctx</code></strong> — external context, same role as <code class="language-plaintext highlighter-rouge">dm.ctx</code>. For reactions, this is typically read-model queries: “what is the current state of the target aggregate?” These queries target eventually consistent projections — a fact worth keeping visible in the specification.</p> <p>The outcome model for reactions contains <code class="language-plaintext highlighter-rouge">om.commands</code> — the ordered list of commands to be dispatched — instead of <code class="language-plaintext highlighter-rouge">om.evts</code>. Assertions verify that the right commands are dispatched to the right targets with the right data.</p> <h3 id="multiple-triggers"> <a href="#multiple-triggers" class="anchor-heading" aria-labelledby="multiple-triggers"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Multiple Triggers </h3> <p>A reaction may be triggered by more than one event. Two patterns exist, and they are fundamentally different:</p> <p><strong>OR — any of these events.</strong> Several events trigger the same reaction. Only one event has occurred; the reaction runs once. This is common when events are variants of the same domain occurrence: “assessment submitted fully met” and “assessment submitted with gaps” both trigger the same review workflow.</p> <p>In UbiSpec, this is expressed with <code class="language-plaintext highlighter-rouge">When: { any: [...] }</code>. The <code class="language-plaintext highlighter-rouge">rm.event</code> is typed as a discriminated union of the listed events — it is always exactly one event, and the reaction uses the event’s <code class="language-plaintext highlighter-rouge">kind</code> field to distinguish variants when the logic differs.</p> <p>A note on typing: each predicate in a UbiSpec is a standalone expression. Discriminated union narrowing in TypeScript is control-flow based — it works within an expression (e.g., <code class="language-plaintext highlighter-rouge">rm.event.kind === 'X' &amp;&amp; rm.event.specificField</code>) but does not carry across separate predicate expressions. In UbiSpec, the conditional structure provides the narrowing context: a conditional command’s predicates establish which event variant is present, and outcome assertions under that command key can safely reference variant-specific fields. This is a specification convention, not a language feature — tooling that validates predicate expressions should respect the conditional hierarchy as a narrowing boundary.</p> <p><strong>AND — all of these events must arrive.</strong> The reaction waits for multiple events — potentially from different aggregates, arriving at different times — before acting. This is the scatter-gather or join pattern.</p> <p>In UbiSpec, this is expressed with <code class="language-plaintext highlighter-rouge">When: { all: [...] }</code> combined with a <code class="language-plaintext highlighter-rouge">correlate</code> field that declares how events are matched to the same instance. Each event’s payload is accessible by name via <code class="language-plaintext highlighter-rouge">rm.events.EventName</code> — no union, no narrowing needed, each event has its concrete type.</p> <p>The runtime handles accumulation: events arrive in any order, are stored by correlation key, and the reaction fires once when the set is complete. The spec author describes the completed state — what happens when all events are present — not the mechanics of accumulation.</p> <p>The distinction matters because OR is a specification convenience (deduplicating similar reactions), while AND is a coordination mechanism (waiting for convergence). UbiSpec makes this distinction explicit: <code class="language-plaintext highlighter-rouge">any</code> for OR, <code class="language-plaintext highlighter-rouge">all</code> for AND, each with its own namespace pattern.</p> <h2 id="composition-from-decisions-to-systems"> <a href="#composition-from-decisions-to-systems" class="anchor-heading" aria-labelledby="composition-from-decisions-to-systems"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Composition: From Decisions to Systems </h2> <p>Decisions and reactions are the atomic building blocks. They compose into larger structures:</p> <p><strong>An aggregate</strong> is one or more decisions sharing an identity. In the simplest case, one decision per command, all operating on the same state. In Eric Evans’ Domain-Driven Design, an aggregate is a consistency boundary — everything inside it is transactionally consistent. A Lifecycle UbiSpec captures one aggregate.</p> <p><strong>A process</strong> emerges when decisions are linked by reactions within the same subsystem. Event A on aggregate X triggers a command on aggregate Y, which produces event B, which triggers a command on aggregate Z. The reactions form a choreography — a chain of cause and effect. A Process UbiSpec captures these reactions.</p> <p><strong>A workflow</strong> spans subsystem boundaries. When reactions connect processes in different bounded contexts — each with their own models, their own language, their own deployment boundaries — the coordination becomes a long-running workflow. The same Process UbiSpec format applies, but the <code class="language-plaintext highlighter-rouge">reacts_to</code> and <code class="language-plaintext highlighter-rouge">emits_to</code> declarations cross context boundaries, making the coupling explicit and visible.</p> <p>This composition is fractal. A complex system is processes made of reactions linking decisions. A complex process is a chain of reactions. A complex decision is constraints and conditional events. At every level, the same two primitives — “command in, events out” and “events in, commands out” — do the work.</p> <h2 id="the-naming-principle"> <a href="#the-naming-principle" class="anchor-heading" aria-labelledby="the-naming-principle"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> The Naming Principle </h2> <p>Every constraint, condition, and assertion in a UbiSpec has a <strong>name</strong> — a kebab-case identifier that reads as natural language.</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="s">reviewer-is-authorised</span>
<span class="pi">-</span> <span class="s">has-active-registry</span>
<span class="pi">-</span> <span class="s">state-is-active</span>
<span class="pi">-</span> <span class="s">catalog-unchanged</span>
</code></pre></div></div> <p>This is not documentation. The names are the specification. They carry the meaning. A domain expert can read a UbiSpec with names only (no predicate expressions) and validate whether the behaviour is correct. The expressions add precision for developers and machines, but the names are what the team agrees on.</p> <p>This design enables the <strong>two-pass workflow</strong> that UbiSpec is built around. The first pass — with domain experts — produces a specification in natural language, structured as When/And/Then/Outcome. The second pass — with developers — adds executable expressions to each name. Same artifact, different audiences, no translation step between them.</p> <p>The names also serve as the <strong>ubiquitous language</strong> that Eric Evans identified as central to domain-driven design. When a constraint is named <code class="language-plaintext highlighter-rouge">reviewer-is-authorised</code>, that phrase should mean the same thing in conversations, in specifications, in code, and in error messages. The implicit failure convention reinforces this: when a constraint fails, the <code class="language-plaintext highlighter-rouge">DecisionFailed</code> event carries the constraint name as the failure reason. The specification, the error message, and the test assertion all use the same words.</p> <h2 id="namespaces-over-expressions"> <a href="#namespaces-over-expressions" class="anchor-heading" aria-labelledby="namespaces-over-expressions"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Namespaces Over Expressions </h2> <p>If names are the specification, what is the role of the value — the part after the colon?</p> <p>The instinct is to say “that’s where the code goes.” And it can be. But the real value is not in code. It is in the <strong>namespaces</strong>: <code class="language-plaintext highlighter-rouge">dm.cmd</code>, <code class="language-plaintext highlighter-rouge">dm.state</code>, <code class="language-plaintext highlighter-rouge">dm.ctx</code>, <code class="language-plaintext highlighter-rouge">om.state</code>, <code class="language-plaintext highlighter-rouge">om.evts</code>, <code class="language-plaintext highlighter-rouge">rm.event</code>, <code class="language-plaintext highlighter-rouge">rm.events</code>, <code class="language-plaintext highlighter-rouge">rm.ctx</code>, <code class="language-plaintext highlighter-rouge">om.commands</code>. These namespaces are the conceptual contribution. They provide a vocabulary for describing where behavioural data lives, which is a question every system must answer regardless of implementation language, persistence strategy, or architecture style.</p> <p>Consider the difference between these two predicates:</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="s">reviewer-is-authorised</span>
</code></pre></div></div> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">reviewer-is-authorised</span><span class="pi">:</span> <span class="s">dm.ctx</span>
</code></pre></div></div> <p>The first says the constraint exists. The second says <em>the data needed to evaluate this constraint lives outside the aggregate</em>. That single annotation — <code class="language-plaintext highlighter-rouge">dm.ctx</code> — tells you:</p> <ul> <li>This is a <strong>shell dependency</strong>. Something must look this up before the decision runs.</li> <li>The decision function is <strong>not self-contained</strong> for this command. It needs external context.</li> <li>There is an <strong>integration point</strong> here. A service, a read model, an external system.</li> <li>This constraint <strong>cannot be tested</strong> with just the aggregate’s own state and the command.</li> </ul> <p>All of that from two words. No code. No type system. No language dependency.</p> <p>Now consider the full spectrum of what a predicate value can be:</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># The constraint exists</span>
<span class="pi">-</span> <span class="s">reviewer-is-authorised</span>

<span class="c1"># The constraint needs external context</span>
<span class="pi">-</span> <span class="na">reviewer-is-authorised</span><span class="pi">:</span> <span class="s">dm.ctx</span>

<span class="c1"># The constraint means this, needs external context</span>
<span class="pi">-</span> <span class="na">reviewer-is-authorised</span><span class="pi">:</span> <span class="s2">"</span><span class="s">The</span><span class="nv"> </span><span class="s">reviewer</span><span class="nv"> </span><span class="s">must</span><span class="nv"> </span><span class="s">be</span><span class="nv"> </span><span class="s">a</span><span class="nv"> </span><span class="s">national</span><span class="nv"> </span><span class="s">authority</span><span class="nv"> </span><span class="s">(dm.ctx)"</span>

<span class="c1"># The constraint evaluates to this expression</span>
<span class="pi">-</span> <span class="na">reviewer-is-authorised</span><span class="pi">:</span> <span class="s2">"</span><span class="s">dm.ctx.isNationalAuthority"</span>
</code></pre></div></div> <p>These four levels are not a progression from incomplete to complete. They are a progression from general to precise, and each level is a valid specification for a different audience and a different stage of the work.</p> <p>A specification at Level 1 (names only) is what you write during or immediately after a discovery session. It captures the behavioural structure — what commands exist, what constrains them, what they produce — without committing to data shapes or implementation details. This is already sufficient to generate user stories, acceptance criteria, test scenario outlines, and workflow documentation.</p> <p>A specification at Level 2 (scope annotations) adds architectural information. Scanning a spec for <code class="language-plaintext highlighter-rouge">dm.ctx</code> references tells you which commands have shell dependencies. Scanning for <code class="language-plaintext highlighter-rouge">[dm.cmd, dm.state]</code> tells you which constraints compare inputs against current state. Scanning for <code class="language-plaintext highlighter-rouge">[om.state, dm.state]</code> tells you which assertions verify change detection. This is the information an architect needs to understand the system’s integration surface and purity boundaries — and it requires no code at all.</p> <p>A specification at Level 3 (prose descriptions) serves as documentation. Each predicate reads as a sentence: “The reviewer must be a national authority.” This is the level that works in contractual or regulatory contexts where behaviour must be described in natural language but still structured enough to trace and validate.</p> <p>A specification at Level 4 (executable expressions) is where machines take over. The expressions can be validated against a domain model, used to generate test assertions, used to generate implementation code. This is the precision pass — the developer pass — and it adds executable power to the structural foundation laid by the earlier levels.</p> <p>The key insight is that <strong>the namespaces work at every level</strong>. <code class="language-plaintext highlighter-rouge">dm.ctx</code> is meaningful whether the value is an empty annotation, a prose description, or a TypeScript expression. The namespace vocabulary — decision model, outcome model, reaction model — is the constant. The expression language is a variable.</p> <p>This is why UbiSpec is not tied to TypeScript, despite using TypeScript expressions in its examples and tooling. The namespace structure (<code class="language-plaintext highlighter-rouge">dm.cmd</code>, <code class="language-plaintext highlighter-rouge">dm.state</code>, <code class="language-plaintext highlighter-rouge">dm.ctx</code>) is a general vocabulary for describing behavioural data flow. A team working in Kotlin would write <code class="language-plaintext highlighter-rouge">dm.state.status is Draft</code> instead of <code class="language-plaintext highlighter-rouge">dm.state.status.kind === 'Draft'</code>. A team working in F# would write <code class="language-plaintext highlighter-rouge">dm.state.Status = Draft</code>. The structure and the namespaces are the same. The expressions are native to the implementation language.</p> <p>And a team that is not writing code at all — that is capturing behaviour for documentation, validation, or contractual purposes — can use Levels 1 through 3 and never write an expression. The specification is still structured, still traceable, still capable of generating stories and test scenarios. The expressions are an option, not a requirement.</p> <h2 id="acknowledgements"> <a href="#acknowledgements" class="anchor-heading" aria-labelledby="acknowledgements"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Acknowledgements </h2> <p>UbiSpec builds on the work of:</p> <ul> <li><strong>Alberto Brandolini</strong> — <a href="https://www.eventstorming.com/">EventStorming</a> and its visual grammar of commands, events, and policies</li> <li><strong>Jérémie Chassaing</strong> — the <a href="https://thinkbeforecoding.com/post/2021/12/17/functional-event-sourcing-decider">Decider pattern</a> (decide/evolve/initial)</li> <li><strong>Eric Evans</strong> — <a href="https://www.domainlanguage.com/ddd/">Domain-Driven Design</a>, aggregates, bounded contexts, ubiquitous language</li> <li><strong>Dan North</strong> — <a href="https://dannorth.net/introducing-bdd/">Behaviour-Driven Development</a> and the Given/When/Then structure</li> <li><strong>Gojko Adzic</strong> — <a href="https://gojko.net/books/specification-by-example/">Specification by Example</a>, executable specifications as living documentation</li> <li><strong>Matt Wynne and the BDD community</strong> — <a href="https://cucumber.io/blog/bdd/example-mapping-introduction/">Example Mapping</a> as a structured discovery technique</li> </ul> <p>UbiSpec does not replace these practices. It gives their output a structured, durable format — one that survives the workshop, generates downstream artifacts, and evolves with the system.</p> </main> <hr> <footer> <p class="text-small mb-0">UbiSpec is open source under the MIT License.</p> <div class="d-md-none mt-4 fs-2"> This site uses <a href="https://github.com/just-the-docs/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </div> </footer> </div> </div> <div class="search-overlay"></div> </div> <script src="https://cdn.jsdelivr.net/npm/mermaid@9.1.3/dist/mermaid.min.js"></script> <script> var config = {} ; mermaid.initialize(config); window.mermaid.init(undefined, document.querySelectorAll('.language-mermaid')); </script> </body> </html>
