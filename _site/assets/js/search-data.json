{"0": {
    "doc": "Home",
    "title": "UbiSpec",
    "content": "Ubiquitous Specification Format for Software Systems’ Behaviour . UbiSpec is a structured YAML/JSON format used to encode the intended behaviour of software systems, a.k.a. their underlying domain model. It is ubiquitous because it is meant to support different actors involved in different stages of the entire Software Development Lyfecycle (SDLC). The format is readable by humans, deterministic machines, and LLM Agents, enabling manual, deterministic or agentic use and artifacts generation. In essence, UbiSpec enables allignment between all participants - humans, deterministic machines, LLM agents - at all stages of the SDLC, by providing a consistent formalization of the undelying domain model for any software system under design, construction, or maintenance. UbiSpec is in early development. Feel free to look around, experiment, and make sure to reach out for any comments and suggestions. We beleive this has potential. Get started Specs Guide Design principles Go to Playground View on GitHub . ",
    "url": "/#ubispec",
    
    "relUrl": "/#ubispec"
  },"1": {
    "doc": "Home",
    "title": "Specification Formats",
    "content": "UbiSpec currently defines two formats: . | Format | File | Captures | . | Lifecycle UbiSpec | *.lifecycle.ubispec.yaml | Single aggregate behaviour: commands, conditions, outcomes | . | Process UbiSpec | *.process.ubispec.yaml | Cross-aggregate coordination: event reactions, command dispatch | . ",
    "url": "/#specification-formats",
    
    "relUrl": "/#specification-formats"
  },"2": {
    "doc": "Home",
    "title": "Practices UbiSpec Operationalises",
    "content": "UbiSpec is informed by and designed to complement: . | Domain-Driven Design — bounded contexts, aggregates, ubiquitous language | EventStorming — commands, events, policies, read models, aggregate boundaries | Behaviour-Driven Development — specifications as tests, natural language acceptance criteria | Specification by Example — concrete scenarios that define expected behaviour | Example Mapping — rules, examples, and questions structured by story | . UbiSpec doesn’t replace these practices. It gives their output a durable, structured format that generates downstream artifacts instead of gathering dust. ",
    "url": "/#practices-ubispec-operationalises",
    
    "relUrl": "/#practices-ubispec-operationalises"
  },"3": {
    "doc": "Home",
    "title": "Status",
    "content": "UbiSpec is in early development. The Lifecycle and Process formats are stable enough to use. Tooling (validator CLI, test generator, story generator) is planned. Feedback, examples, and contributions are welcome. ",
    "url": "/#status",
    
    "relUrl": "/#status"
  },"4": {
    "doc": "Home",
    "title": "License",
    "content": "MIT . ",
    "url": "/#license",
    
    "relUrl": "/#license"
  },"5": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"6": {
    "doc": "Conceptual Foundations",
    "title": "Conceptual Foundations",
    "content": "This page explains the reasoning behind UbiSpec: where the format comes from, why it takes the shape it does, and how each design choice follows from the one before it. ",
    "url": "/guide/conceptual-foundations.html",
    
    "relUrl": "/guide/conceptual-foundations.html"
  },"7": {
    "doc": "Conceptual Foundations",
    "title": "Starting Point: EventStorming’s Visual Grammar",
    "content": "UbiSpec owes its primary debt to EventStorming, created by Alberto Brandolini. EventStorming provides a visual grammar for exploring system behaviour using sticky notes — commands, events, policies, aggregates, read models — that a room full of people can arrange on a wall to build a shared understanding of a domain. What makes EventStorming powerful is not the sticky notes. It is the two fundamental sequences that compose all system behaviour: . The command-led sequence. A user (or system) issues a command. The command is evaluated against the current state. If accepted, one or more events are produced. These events represent what happened — facts about the system’s history. Command → [conditions] → Event(s) . The policy sequence. An event is observed. A policy decides whether and how to react. If it reacts, it issues one or more commands, which feed into other command-led sequences. Event(s) → [policy logic] → Command(s) . These two sequences compose. A command produces events, which trigger policies, which issue commands, which produce events. Any system behaviour — however complex — can be decomposed into these two building blocks chained together. UbiSpec formalises these two sequences into two specification formats: . | EventStorming | UbiSpec | File | . | Command-led sequence | Decision | Lifecycle UbiSpec | . | Policy sequence | Reaction | Process UbiSpec | . The entire format follows from this decomposition. ",
    "url": "/guide/conceptual-foundations.html#starting-point-eventstormings-visual-grammar",
    
    "relUrl": "/guide/conceptual-foundations.html#starting-point-eventstormings-visual-grammar"
  },"8": {
    "doc": "Conceptual Foundations",
    "title": "Decisions: The Structure of a Command-Led Sequence",
    "content": "A decision is what happens when a command arrives. If we dissect a decision carefully, an intrinsic logical structure emerges that can explain all possible configurations. A command produces one or more events if some conditions are met. These conditions are constraints — business rules, state guards, authorisation checks, validation rules. They must all hold for the command to succeed. If any constraint fails, the result is a domain failure. The command was attempted but could not proceed. The failure is directly linked to the constraints that were not satisfied. If we abstract the failure by convention — by saying that a failed constraint always produces a standard DecisionFailed event carrying the names of the constraints that failed — then we can focus the specification entirely on the success path. The failure scenarios are implicit: for each constraint, there is a failure scenario where it is violated. The constraint names become the failure reasons. No separate failure specification is needed. This is not a simplification for convenience. It is a design principle: the specification describes what the system can do, not all the ways it can refuse. The refusal cases are mechanically derivable from the success cases. But not all events are always emitted on success. Some events are conditional — they depend on additional branching logic beyond the entry constraints. An order approval might always produce an OrderApproved event, but only produce an ArchivalTriggered event when a previous active version exists. So a decision has four elements: . | Command — the trigger | Constraints — what must hold for the command to succeed | Events — what is produced on success, some unconditional, some conditional | Branching logic — conditions determining which conditional events fire | . This accounts for every configuration a command-led sequence can take. ",
    "url": "/guide/conceptual-foundations.html#decisions-the-structure-of-a-command-led-sequence",
    
    "relUrl": "/guide/conceptual-foundations.html#decisions-the-structure-of-a-command-led-sequence"
  },"9": {
    "doc": "Conceptual Foundations",
    "title": "The Decision Model: What Data Does a Decision Need?",
    "content": "To evaluate constraints and branching logic, the decision needs data. If we ask what data? systematically, three distinct sources emerge: . The command itself (dm.cmd). The command carries the user’s intent and any request metadata — the payload they submitted. “Approve this registry. Here is my reviewer ID and the effective date.” . The current state of the aggregate (dm.state). The system’s current knowledge about this entity — its status, its contents, its history of changes. “The registry is in Submitted status. It has three profiles.” . External context (dm.ctx). Information that lives outside the aggregate — in another service, in a clock, in a read model. The aggregate can’t know this from its own history; something must look it up before the decision runs. “Is this reviewer authorised? Is another registry currently active?” . These three sources — command, state, context — are the decision model. In UbiSpec, they form the dm namespace: dm.cmd, dm.state, dm.ctx. The context namespace does quiet but important work. Every dm.ctx reference in a specification is a shell contract: a declaration that the runtime environment must resolve this value before the decision function is called. An agent or developer can scan a specification for all dm.ctx references and mechanically derive the integration points for each command. Nothing is hidden. The three-namespace structure also makes the purity boundary explicit. dm.cmd and dm.state are synchronous and deterministic — they are values already available. dm.ctx is the seam where the outside world enters. The decision function itself is pure: given (cmd, state, ctx), it produces the same events every time. The impurity is isolated in the shell that resolves the context before the decision runs. ",
    "url": "/guide/conceptual-foundations.html#the-decision-model-what-data-does-a-decision-need",
    
    "relUrl": "/guide/conceptual-foundations.html#the-decision-model-what-data-does-a-decision-need"
  },"10": {
    "doc": "Conceptual Foundations",
    "title": "Events and State: What Changes?",
    "content": "A decision produces events. But what are events? Do they represent a change in state, or do they trigger a change in state? . This is where the work of Jérémie Chassaing on the Decider pattern becomes foundational. Chassaing formalised a functional representation of an event-sourced aggregate as three elements: . decide: (command, state) → event[] evolve: (state, event) → state initial: state . The decide function makes the decision — given a command and the current state, what events are produced? The evolve function applies an event to a state, producing the new state. The initial value is the starting state before any events have occurred. State is derived by folding events: state = events.reduce(evolve, initial). The events are the source of truth. State is a computation over them. This separation offers several practical advantages: . Auditability. The event stream is a complete record of what happened and why. State is a projection — a view derived from history. You can always explain how the system arrived at its current state by replaying the events. Testability. The decide function is pure: same inputs, same outputs. No side effects, no database calls, no external dependencies (those are resolved in the context before decide runs). This makes property-based testing natural: for any valid combination of command, state, and context, assert that the produced events satisfy the specification. Composability. Multiple views (read models, projections, analytics) can be derived from the same event stream. Each view folds the events differently. The events are shared; the interpretations are independent. Separation of concerns. The decision logic (what events to produce) is separate from the state transition logic (how to apply an event). This prevents a common mistake: mixing business rule validation with state mutation, which makes both harder to reason about and test. UbiSpec captures the decide side of this pattern — what events a command produces under what conditions. The evolve side is implied by the outcome assertions: “after these events are applied, these things must be true about the state.” The Lifecycle UbiSpec is, in essence, a formal contract for both sides of the Decider pattern. It is worth noting that event sourcing is a natural fit for this model but not a requirement. The decision/reaction decomposition, the namespace model, and the specification structure all work regardless of how state is persisted. A system using traditional state storage can still benefit from specifying behaviour as decisions and reactions with clear input and output models. ",
    "url": "/guide/conceptual-foundations.html#events-and-state-what-changes",
    
    "relUrl": "/guide/conceptual-foundations.html#events-and-state-what-changes"
  },"11": {
    "doc": "Conceptual Foundations",
    "title": "The Outcome Model: Verifying What Happened",
    "content": "A decision produces events. Events are applied to state via evolve. But how do we verify that the right thing happened? . The outcome model (om) provides the verification context. After all events have been applied, the outcome model exposes: . om.state — the new state after evolve. This is where we assert what changed: “the registry is now Active”, “the line item is in the catalog.” . om.evts — the events that were emitted. This is where we assert what happened: “a RegistryApproved event was produced”, “the event carries the correct effective date.” . Crucially, outcome assertions also have access to the decision model — dm.state (the state before), dm.cmd (the original command), and dm.ctx (the resolved context). This enables three essential categories of assertion: . Positive assertions. What changed. “State is Active. Effective date is set.” . Negative assertions. What must not change. “The test catalog is unchanged. Other assignments are preserved.” These catch accidental side effects — an evolve function that inadvertently clears unrelated state would fail a negative assertion even if all positive assertions pass. Data flow assertions. The outputs carry the right data from the inputs. “The event’s effective date matches the command’s effective date. The archival event targets the correct registry ID from the context.” These verify that information flows correctly through the decision without being lost or garbled. The outcome model closes the specification loop. The decision model defines what goes in. The constraints and event conditions define the logic. The outcome model defines what must come out. Together, they form a complete behavioural contract that can be verified mechanically — as a test suite, as a property-based test, or as a runtime assertion. ",
    "url": "/guide/conceptual-foundations.html#the-outcome-model-verifying-what-happened",
    
    "relUrl": "/guide/conceptual-foundations.html#the-outcome-model-verifying-what-happened"
  },"12": {
    "doc": "Conceptual Foundations",
    "title": "Reactions: The Structure of a Policy Sequence",
    "content": "Where a decision transforms commands into events within one aggregate, a reaction coordinates between aggregates. An event on one aggregate triggers commands on another. The reaction model (rm) mirrors the decision model, but the inputs are different: . rm.event — the triggering event, analogous to dm.cmd. Where a decision is triggered by a user’s intent (a command), a reaction is triggered by a fact about what happened (an event). rm.state — the process manager’s own state, if it is stateful. Most reactions are stateless — they receive an event and immediately determine what commands to dispatch. Stateful reactions (sagas) track progress across multiple events, for example waiting for several confirmations before proceeding. rm.ctx — external context, same role as dm.ctx. For reactions, this is typically read-model queries: “what is the current state of the target aggregate?” These queries target eventually consistent projections — a fact worth keeping visible in the specification. The outcome model for reactions contains om.commands — the ordered list of commands to be dispatched — instead of om.evts. Assertions verify that the right commands are dispatched to the right targets with the right data. Multiple Triggers . A reaction may be triggered by more than one event. Two patterns exist, and they are fundamentally different: . OR — any of these events. Several events trigger the same reaction. Only one event has occurred; the reaction runs once. This is common when events are variants of the same domain occurrence: “assessment submitted fully met” and “assessment submitted with gaps” both trigger the same review workflow. In UbiSpec, this is expressed with When: { any: [...] }. The rm.event is typed as a discriminated union of the listed events — it is always exactly one event, and the reaction uses the event’s kind field to distinguish variants when the logic differs. A note on typing: each predicate in a UbiSpec is a standalone expression. Discriminated union narrowing in TypeScript is control-flow based — it works within an expression (e.g., rm.event.kind === 'X' &amp;&amp; rm.event.specificField) but does not carry across separate predicate expressions. In UbiSpec, the conditional structure provides the narrowing context: a conditional command’s predicates establish which event variant is present, and outcome assertions under that command key can safely reference variant-specific fields. This is a specification convention, not a language feature — tooling that validates predicate expressions should respect the conditional hierarchy as a narrowing boundary. AND — all of these events must arrive. The reaction waits for multiple events — potentially from different aggregates, arriving at different times — before acting. This is the scatter-gather or join pattern. In UbiSpec, this is expressed with When: { all: [...] } combined with a correlate field that declares how events are matched to the same instance. Each event’s payload is accessible by name via rm.events.EventName — no union, no narrowing needed, each event has its concrete type. The runtime handles accumulation: events arrive in any order, are stored by correlation key, and the reaction fires once when the set is complete. The spec author describes the completed state — what happens when all events are present — not the mechanics of accumulation. The distinction matters because OR is a specification convenience (deduplicating similar reactions), while AND is a coordination mechanism (waiting for convergence). UbiSpec makes this distinction explicit: any for OR, all for AND, each with its own namespace pattern. ",
    "url": "/guide/conceptual-foundations.html#reactions-the-structure-of-a-policy-sequence",
    
    "relUrl": "/guide/conceptual-foundations.html#reactions-the-structure-of-a-policy-sequence"
  },"13": {
    "doc": "Conceptual Foundations",
    "title": "Composition: From Decisions to Systems",
    "content": "Decisions and reactions are the atomic building blocks. They compose into larger structures: . An aggregate is one or more decisions sharing an identity. In the simplest case, one decision per command, all operating on the same state. In Eric Evans’ Domain-Driven Design, an aggregate is a consistency boundary — everything inside it is transactionally consistent. A Lifecycle UbiSpec captures one aggregate. A process emerges when decisions are linked by reactions within the same subsystem. Event A on aggregate X triggers a command on aggregate Y, which produces event B, which triggers a command on aggregate Z. The reactions form a choreography — a chain of cause and effect. A Process UbiSpec captures these reactions. A workflow spans subsystem boundaries. When reactions connect processes in different bounded contexts — each with their own models, their own language, their own deployment boundaries — the coordination becomes a long-running workflow. The same Process UbiSpec format applies, but the reacts_to and emits_to declarations cross context boundaries, making the coupling explicit and visible. This composition is fractal. A complex system is processes made of reactions linking decisions. A complex process is a chain of reactions. A complex decision is constraints and conditional events. At every level, the same two primitives — “command in, events out” and “events in, commands out” — do the work. ",
    "url": "/guide/conceptual-foundations.html#composition-from-decisions-to-systems",
    
    "relUrl": "/guide/conceptual-foundations.html#composition-from-decisions-to-systems"
  },"14": {
    "doc": "Conceptual Foundations",
    "title": "The Naming Principle",
    "content": "Every constraint, condition, and assertion in a UbiSpec has a name — a kebab-case identifier that reads as natural language. - reviewer-is-authorised - has-active-registry - state-is-active - catalog-unchanged . This is not documentation. The names are the specification. They carry the meaning. A domain expert can read a UbiSpec with names only (no predicate expressions) and validate whether the behaviour is correct. The expressions add precision for developers and machines, but the names are what the team agrees on. This design enables the two-pass workflow that UbiSpec is built around. The first pass — with domain experts — produces a specification in natural language, structured as When/And/Then/Outcome. The second pass — with developers — adds executable expressions to each name. Same artifact, different audiences, no translation step between them. The names also serve as the ubiquitous language that Eric Evans identified as central to domain-driven design. When a constraint is named reviewer-is-authorised, that phrase should mean the same thing in conversations, in specifications, in code, and in error messages. The implicit failure convention reinforces this: when a constraint fails, the DecisionFailed event carries the constraint name as the failure reason. The specification, the error message, and the test assertion all use the same words. ",
    "url": "/guide/conceptual-foundations.html#the-naming-principle",
    
    "relUrl": "/guide/conceptual-foundations.html#the-naming-principle"
  },"15": {
    "doc": "Conceptual Foundations",
    "title": "Namespaces Over Expressions",
    "content": "If names are the specification, what is the role of the value — the part after the colon? . The instinct is to say “that’s where the code goes.” And it can be. But the real value is not in code. It is in the namespaces: dm.cmd, dm.state, dm.ctx, om.state, om.evts, rm.event, rm.events, rm.ctx, om.commands. These namespaces are the conceptual contribution. They provide a vocabulary for describing where behavioural data lives, which is a question every system must answer regardless of implementation language, persistence strategy, or architecture style. Consider the difference between these two predicates: . - reviewer-is-authorised . - reviewer-is-authorised: dm.ctx . The first says the constraint exists. The second says the data needed to evaluate this constraint lives outside the aggregate. That single annotation — dm.ctx — tells you: . | This is a shell dependency. Something must look this up before the decision runs. | The decision function is not self-contained for this command. It needs external context. | There is an integration point here. A service, a read model, an external system. | This constraint cannot be tested with just the aggregate’s own state and the command. | . All of that from two words. No code. No type system. No language dependency. Now consider the full spectrum of what a predicate value can be: . # The constraint exists - reviewer-is-authorised # The constraint needs external context - reviewer-is-authorised: dm.ctx # The constraint means this, needs external context - reviewer-is-authorised: \"The reviewer must be a national authority (dm.ctx)\" # The constraint evaluates to this expression - reviewer-is-authorised: \"dm.ctx.isNationalAuthority\" . These four levels are not a progression from incomplete to complete. They are a progression from general to precise, and each level is a valid specification for a different audience and a different stage of the work. A specification at Level 1 (names only) is what you write during or immediately after a discovery session. It captures the behavioural structure — what commands exist, what constrains them, what they produce — without committing to data shapes or implementation details. This is already sufficient to generate user stories, acceptance criteria, test scenario outlines, and workflow documentation. A specification at Level 2 (scope annotations) adds architectural information. Scanning a spec for dm.ctx references tells you which commands have shell dependencies. Scanning for [dm.cmd, dm.state] tells you which constraints compare inputs against current state. Scanning for [om.state, dm.state] tells you which assertions verify change detection. This is the information an architect needs to understand the system’s integration surface and purity boundaries — and it requires no code at all. A specification at Level 3 (prose descriptions) serves as documentation. Each predicate reads as a sentence: “The reviewer must be a national authority.” This is the level that works in contractual or regulatory contexts where behaviour must be described in natural language but still structured enough to trace and validate. A specification at Level 4 (executable expressions) is where machines take over. The expressions can be validated against a domain model, used to generate test assertions, used to generate implementation code. This is the precision pass — the developer pass — and it adds executable power to the structural foundation laid by the earlier levels. The key insight is that the namespaces work at every level. dm.ctx is meaningful whether the value is an empty annotation, a prose description, or a TypeScript expression. The namespace vocabulary — decision model, outcome model, reaction model — is the constant. The expression language is a variable. This is why UbiSpec is not tied to TypeScript, despite using TypeScript expressions in its examples and tooling. The namespace structure (dm.cmd, dm.state, dm.ctx) is a general vocabulary for describing behavioural data flow. A team working in Kotlin would write dm.state.status is Draft instead of dm.state.status.kind === 'Draft'. A team working in F# would write dm.state.Status = Draft. The structure and the namespaces are the same. The expressions are native to the implementation language. And a team that is not writing code at all — that is capturing behaviour for documentation, validation, or contractual purposes — can use Levels 1 through 3 and never write an expression. The specification is still structured, still traceable, still capable of generating stories and test scenarios. The expressions are an option, not a requirement. ",
    "url": "/guide/conceptual-foundations.html#namespaces-over-expressions",
    
    "relUrl": "/guide/conceptual-foundations.html#namespaces-over-expressions"
  },"16": {
    "doc": "Conceptual Foundations",
    "title": "Acknowledgements",
    "content": "UbiSpec builds on the work of: . | Alberto Brandolini — EventStorming and its visual grammar of commands, events, and policies | Jérémie Chassaing — the Decider pattern (decide/evolve/initial) | Eric Evans — Domain-Driven Design, aggregates, bounded contexts, ubiquitous language | Dan North — Behaviour-Driven Development and the Given/When/Then structure | Gojko Adzic — Specification by Example, executable specifications as living documentation | Matt Wynne and the BDD community — Example Mapping as a structured discovery technique | . UbiSpec does not replace these practices. It gives their output a structured, durable format — one that survives the workshop, generates downstream artifacts, and evolves with the system. ",
    "url": "/guide/conceptual-foundations.html#acknowledgements",
    
    "relUrl": "/guide/conceptual-foundations.html#acknowledgements"
  },"17": {
    "doc": "Example artifacts",
    "title": "UbiSpec — Derived Artifact Examples",
    "content": "Each artifact below is mechanically generated from the same UbiSpec YAML. No interpretation, no LLM — just structural transformation. Source spec used for lifecycle examples: . - When: ApproveRegistry And: - registry-is-submitted: \"dm.state.status.kind === 'SubmittedForReview'\" - reviewer-is-authorised: dm.ctx - no-unresolved-comments: dm.state Then: - RegistryApproved - PreviousRegistryArchived: - has-active-registry: \"dm.ctx.currentActiveRegistryId != null\" Outcome: _always: - state-is-active: om.state - effective-date-set: [om.state, dm.cmd] - approval-recorded: [om.evts, dm.cmd] PreviousRegistryArchived: - archival-target-correct: [om.evts, dm.ctx] - previous-deactivated: om.state . Source spec used for process examples: . process: OrderFulfillmentManager reacts_to: [Order, Payment, Inventory] emits_to: [Inventory, Payment, Fulfillment, Notification] reactions: - When: OrderPlaced From: Order Then: - ReserveInventory -&gt; Inventory - InitiatePaymentCapture -&gt; Payment - When: all: - PaymentConfirmed from Payment - InventoryReserved from Inventory correlate: orderId Then: ScheduleShipment -&gt; Fulfillment - When: OrderCancelled From: Order Then: - ReleaseInventory -&gt; Inventory - InitiateRefund -&gt; Payment: - payment-was-captured: rm.ctx - SendNotification -&gt; Notification . ",
    "url": "/guide/example-artifacts.html#ubispec--derived-artifact-examples",
    
    "relUrl": "/guide/example-artifacts.html#ubispec--derived-artifact-examples"
  },"18": {
    "doc": "Example artifacts",
    "title": "1. Decision Table",
    "content": "Source: Lifecycle UbiSpec, per command . One table per command. Columns are all evaluable conditions (constraints + event conditions). Rows are all meaningful scenarios. Output column shows which events fire. ApproveRegistry — Decision Table . | # | registry-is-submitted | reviewer-is-authorised | no-unresolved-comments | has-active-registry | → Events | . | 1 | ✓ | ✓ | ✓ | ✓ | RegistryApproved, PreviousRegistryArchived | . | 2 | ✓ | ✓ | ✓ | ✗ | RegistryApproved | . | 3 | ✗ | — | — | — | DecisionFailed [registry-is-submitted] | . | 4 | ✓ | ✗ | — | — | DecisionFailed [reviewer-is-authorised] | . | 5 | ✓ | ✓ | ✗ | — | DecisionFailed [no-unresolved-comments] | . | 6 | ✗ | ✗ | ✗ | — | DecisionFailed [registry-is-submitted, reviewer-is-authorised, no-unresolved-comments] | . Reading the table: . | Rows 1–2: success paths. All constraints pass. Event conditions determine which subset of events fire. | Rows 3–5: single constraint failure. The — means the condition is not evaluated (short-circuit or irrelevant after failure). | Row 6: all constraints fail. All failed names appear in the DecisionFailed payload. | . Generation rule: Constraints are evaluated first (rows 3–6). Only when all pass are event conditions evaluated (rows 1–2). The number of success rows = 2^(number of conditional events). The number of failure rows = at minimum one per constraint, plus optionally one all-fail row. ",
    "url": "/guide/example-artifacts.html#1-decision-table",
    
    "relUrl": "/guide/example-artifacts.html#1-decision-table"
  },"19": {
    "doc": "Example artifacts",
    "title": "2. Test Scenario Matrix",
    "content": "Source: Lifecycle UbiSpec, per command . Each row is a named test case with setup, action, and expected outcome. Directly feeds test implementation. ApproveRegistry — Test Scenarios . | ID | Scenario | Setup | Expected Events | Expected Outcome | . | APR-01 | Happy path with archival | Registry is SubmittedForReview. Reviewer is national authority. No unresolved comments. Another registry is currently active. | RegistryApproved, PreviousRegistryArchived | State is Active. Effective date set. Approval recorded. Archival target correct. Previous deactivated. | . | APR-02 | Happy path without archival | Registry is SubmittedForReview. Reviewer is national authority. No unresolved comments. No other active registry. | RegistryApproved | State is Active. Effective date set. Approval recorded. | . | APR-03 | Rejected: not submitted | Registry is in Draft status. | DecisionFailed [registry-is-submitted] | State unchanged. | . | APR-04 | Rejected: unauthorised reviewer | Registry is SubmittedForReview. Reviewer is not a national authority. | DecisionFailed [reviewer-is-authorised] | State unchanged. | . | APR-05 | Rejected: unresolved comments | Registry is SubmittedForReview. Reviewer is national authority. Has unresolved comments. | DecisionFailed [no-unresolved-comments] | State unchanged. | . Generation rules: . | One happy path per combination of conditional event conditions (2 rows for 1 conditional event, 4 for 2, etc.) | One failure row per constraint | Setup is derived from constraint names (Level 1) or expressions (Level 4) | Expected outcome is derived from Outcome section, keyed by which events fired | Failure outcomes always assert “state unchanged” | ID format: first 3 letters of command + sequential number | . OrderCancelled (Process) — Test Scenarios . | ID | Scenario | Trigger | Expected Commands | Conditions | . | ORC-01 | Cancellation with refund | OrderCancelled, payment was captured | ReleaseInventory → Inventory, InitiateRefund → Payment, SendNotification → Notification | payment-was-captured: ✓ | . | ORC-02 | Cancellation without refund | OrderCancelled, payment was not captured | ReleaseInventory → Inventory, SendNotification → Notification | payment-was-captured: ✗ | . ",
    "url": "/guide/example-artifacts.html#2-test-scenario-matrix",
    
    "relUrl": "/guide/example-artifacts.html#2-test-scenario-matrix"
  },"20": {
    "doc": "Example artifacts",
    "title": "3. Validation Checklist",
    "content": "Source: Lifecycle UbiSpec, per command . For stakeholder sign-off. Each constraint and outcome is a checkbox item derived from the predicate name. No technical detail — just the behavioural contract in plain English. Registry Decider — Validation Checklist . Command: ApproveRegistry . Preconditions: . | Registry is submitted | Reviewer is authorised | No unresolved comments | . On success: . | Registry is approved (always) | Previous registry is archived (when there is an active registry) | . After: . | State is active | Effective date is set | Approval is recorded | If archival occurred: archival target is correct | If archival occurred: previous registry is deactivated | . On failure: . | A DecisionFailed is produced naming the failed preconditions | No state change occurs | . Command: SubmitRegistry (illustrative — from a hypothetical full lifecycle) . Preconditions: . | Registry is draft | Has profiles | All profiles have test entries | . On success: . | Registry is submitted for review | . After: . | State is submitted for review | Submitted date is recorded | Profiles are unchanged | . On failure: . | A DecisionFailed is produced naming the failed preconditions | No state change occurs | . Signed off by: ________ Date: _____ . Generation rules: . | Section per command, ordered as in the lifecycle | Preconditions = And constraints, names converted from kebab-case to sentence case | On success = Then events, annotated with “(always)” or “(when )\" | After = Outcome assertions, grouped by _always and event-keyed | On failure section is identical for every command (the implicit failure convention) | Footer with signature line (configurable template) | . ",
    "url": "/guide/example-artifacts.html#3-validation-checklist",
    
    "relUrl": "/guide/example-artifacts.html#3-validation-checklist"
  },"21": {
    "doc": "Example artifacts",
    "title": "4. Traceability Matrix",
    "content": "Source: All Lifecycle and Process UbiSpec in a bounded context . Traces the relationship between commands, constraints, events, outcomes, and reactions. Every element is cross-referenced. Forward Trace: Command → Events → Reactions → Commands . | Command | Produces | Reacted to by | Dispatches | . | ApproveRegistry | RegistryApproved | — | — | . |   | PreviousRegistryArchived | — | — | . | PlaceOrder | OrderPlaced | OrderFulfillmentManager | ReserveInventory → Inventory | . |   |   |   | InitiatePaymentCapture → Payment | . |   | HighValueOrderFlagged | OrderFulfillmentManager | SendReviewNotification → Notification | . | CancelOrder | OrderCancelled | OrderFulfillmentManager | ReleaseInventory → Inventory | . |   |   |   | InitiateRefund → Payment (conditional) | . |   |   |   | SendNotification → Notification | . Reverse Trace: Constraint → Commands Guarded . | Constraint | Used in | . | registry-is-submitted | ApproveRegistry | . | reviewer-is-authorised | ApproveRegistry | . | no-unresolved-comments | ApproveRegistry | . | registry-is-draft | CreateDraftRegistry, AddProfile, RemoveProfile, AddTestEntry | . | order-is-draft | AddLineItem, RemoveLineItem, PlaceOrder | . | has-lines | PlaceOrder | . | is-cancellable | CancelOrder | . Event → Outcome Assertions . | Event | Assertions verified | . | RegistryApproved | state-is-active, effective-date-set, approval-recorded | . | PreviousRegistryArchived | archival-target-correct, previous-deactivated | . | OrderPlaced | state-is-placed, placed-at-recorded | . | OrderCancelled | state-is-cancelled, reason-recorded | . Impact Analysis: “What breaks if we change X?” . Example query: “What is affected if we remove the reviewer-is-authorised constraint?” . | Element | Relationship | Impact | . | ApproveRegistry | Guarded by constraint | Constraint removed — command now accepts without authorisation check | . | DecisionFailed | References constraint name | Failure scenario APR-04 no longer exists | . | dm.ctx | Scope dependency | May be removable if no other constraint in this command uses dm.ctx | . Generation rules: . | Forward trace: scan all lifecycle Then → match event names in process When → follow Then to dispatched commands | Reverse trace: scan all And sections for each constraint name | Event → assertions: scan all Outcome sections, match by event key | Impact analysis: given an element name, trace all references across all specs in scope | . ",
    "url": "/guide/example-artifacts.html#4-traceability-matrix",
    
    "relUrl": "/guide/example-artifacts.html#4-traceability-matrix"
  },"22": {
    "doc": "Example artifacts",
    "title": "5. Aggregate Topology Diagram",
    "content": "Source: All Process UbiSpec in a system . Extracted from reacts_to, emits_to, When/From, Then -&gt; Target. Pure graph structure. Mermaid Output . graph LR Order --&gt;|OrderPlaced| OFM[OrderFulfillmentManager] Order --&gt;|HighValueOrderFlagged| OFM Order --&gt;|OrderCancelled| OFM Order --&gt;|OrderShipped| OFM Order --&gt;|OrderDelivered| OFM Order --&gt;|FullRefundApproved| OFM Payment --&gt;|PaymentConfirmed| OFM Inventory --&gt;|InventoryReserved| OFM OFM --&gt;|ReserveInventory| Inventory OFM --&gt;|ReleaseInventory| Inventory OFM --&gt;|InitiatePaymentCapture| Payment OFM --&gt;|InitiateRefund| Payment OFM --&gt;|ProcessRefund| Payment OFM --&gt;|ScheduleShipment| Fulfillment OFM --&gt;|SendNotification| Notification OFM --&gt;|SendReviewNotification| Notification style OFM fill:#f0f0f0,stroke:#333 . Join Points (from all triggers) . graph LR Payment --&gt;|PaymentConfirmed| JOIN{AND} Inventory --&gt;|InventoryReserved| JOIN JOIN --&gt;|orderId| OFM[OrderFulfillmentManager] OFM --&gt;|ScheduleShipment| Fulfillment style JOIN fill:#ffcc00,stroke:#333 . Alternative: Text Summary . OrderFulfillmentManager subscribes to: Order: OrderPlaced, HighValueOrderFlagged, OrderCancelled, OrderShipped, OrderDelivered, FullRefundApproved Payment: PaymentConfirmed (via AND join with InventoryReserved, correlate: orderId) Inventory: InventoryReserved (via AND join with PaymentConfirmed, correlate: orderId) dispatches to: Inventory: ReserveInventory, ReleaseInventory Payment: InitiatePaymentCapture, InitiateRefund, ProcessRefund Fulfillment: ScheduleShipment Notification: SendNotification, SendReviewNotification . Generation rules: . | Nodes = unique decider names across all reacts_to and emits_to | Process manager nodes = process names (styled differently) | Inbound edges = When/From pairs, labeled with event name | Outbound edges = Then targets, labeled with command name | AND joins = all triggers rendered as convergence points with correlation key annotation | Output as Mermaid, GraphViz DOT, PlantUML, or JSON adjacency list | . ",
    "url": "/guide/example-artifacts.html#5-aggregate-topology-diagram",
    
    "relUrl": "/guide/example-artifacts.html#5-aggregate-topology-diagram"
  },"23": {
    "doc": "Example artifacts",
    "title": "6. Integration Dependency Manifest",
    "content": "Source: All dm.ctx and rm.ctx references across all UbiSpec . Every ctx reference is a declared external dependency. Scan and catalogue. Per-Command Shell Dependencies . | Decider | Command | Dependency | Scope | Resolution Hint | . | Registry | ApproveRegistry | reviewer-is-authorised | dm.ctx | AuthorityService.check(dm.cmd.reviewedBy) | . | Registry | ApproveRegistry | has-active-registry | dm.ctx | RegistryReadModel.findActive(dm.state.area) | . | Registry | SubmitForReview | all-profiles-complete | dm.ctx | ProfileValidationService.validateAll(dm.state.profiles) | . | Laboratory | ActivateLaboratory | facility-exists | dm.ctx | FacilityRegistry.lookup(dm.cmd.facilityRegistryId) | . | Order | PlaceOrder | all-products-in-stock | dm.ctx | InventoryService.checkAll(dm.state.lines) | . | Order | PlaceOrder | high-value | dm.ctx | PricingService.calculateTotal(dm.state.lines) | . Per-Reaction Shell Dependencies . | Process | Trigger | Dependency | Scope | Resolution Hint | . | AssessmentLifecycleManager | AssessmentAdjusted | adjusted-profile-exists | rm.ctx | RegistryReadModel.profileExists(rm.event.adjustedProfileId) | . | AssessmentLifecycleManager | AssessmentCancelled | has-active-assignment | rm.ctx | LaboratoryReadModel.findById(rm.event.laboratoryId) | . | OrderFulfillmentManager | OrderCancelled | payment-was-captured | rm.ctx | PaymentReadModel.isCaptured(rm.event.orderId) | . Service Dependency Summary . | External Service | Used by Commands | Used by Reactions | . | AuthorityService | ApproveRegistry | — | . | RegistryReadModel | ApproveRegistry | AssessmentAdjusted | . | FacilityRegistry | ActivateLaboratory | — | . | InventoryService | PlaceOrder | — | . | PricingService | PlaceOrder | — | . | ProfileValidationService | SubmitForReview | — | . | LaboratoryReadModel | — | AssessmentCancelled | . | PaymentReadModel | — | OrderCancelled | . Generation rules: . | Scan all predicate values for dm.ctx or rm.ctx (at any level — scope annotation or expression) | Extract # shell: comments for resolution hints | Group by command/reaction, then by external service | At Level 2 (scope only): the dependency is known but the resolution hint is absent | At Level 4 (expression): the full ctx path reveals the expected data shape | . ",
    "url": "/guide/example-artifacts.html#6-integration-dependency-manifest",
    
    "relUrl": "/guide/example-artifacts.html#6-integration-dependency-manifest"
  },"24": {
    "doc": "Example artifacts",
    "title": "7. Command Catalog",
    "content": "Source: All Lifecycle UbiSpec in the system . Flat index of every command the system accepts. System Command Catalog . | # | Decider | Command | Constraints | Events (success) | Conditional Events | Has ctx? | Reacted to? | . | 1 | Registry | CreateDraftRegistry | 2 | 1 | 0 | ✗ | ✗ | . | 2 | Registry | AddProfile | 3 | 1 | 0 | ✗ | ✗ | . | 3 | Registry | RemoveProfile | 3 | 1 | 0 | ✗ | ✗ | . | 4 | Registry | SubmitForReview | 3 | 1 | 0 | ✓ | ✗ | . | 5 | Registry | ApproveRegistry | 3 | 1 | 1 | ✓ | ✗ | . | 6 | Registry | RejectRegistry | 2 | 1 | 0 | ✓ | ✗ | . | 7 | Laboratory | RegisterLaboratory | 2 | 1 | 0 | ✓ | ✗ | . | 8 | Laboratory | ActivateLaboratory | 2 | 1 | 0 | ✓ | ✗ | . | 9 | Laboratory | AssignProfile | 3 | 1 | 0 | ✗ | ✓ | . | 10 | Laboratory | UpdateAssignment | 2 | 1 | 0 | ✗ | ✓ | . | 11 | Laboratory | WithdrawAssignment | 2 | 1 | 0 | ✗ | ✓ | . | 12 | Order | CreateOrder | 1 | 1 | 0 | ✗ | ✗ | . | 13 | Order | AddLineItem | 3 | 1 | 0 | ✗ | ✗ | . | 14 | Order | PlaceOrder | 3 | 1 | 1 | ✓ | ✗ | . | 15 | Order | CancelOrder | 2 | 1 | 1 | ✗ | ✗ | . Summary Statistics . Total commands: 15 Total deciders: 3 Commands with ctx: 6 (40%) — these require shell integration Conditional events: 3 commands have branching logic Reacted to: 3 commands are dispatched by process managers (not user-initiated) . Generation rules: . | One row per command per decider | Constraint count = length of And array | Event count = count of unconditional Then entries | Conditional event count = count of Then entries with conditions | Has ctx = any predicate in And, Then conditions, or Outcome references dm.ctx | Reacted to = command name appears in any Process UbiSpec Then section | Statistics computed from the table | . ",
    "url": "/guide/example-artifacts.html#7-command-catalog",
    
    "relUrl": "/guide/example-artifacts.html#7-command-catalog"
  },"25": {
    "doc": "Example artifacts",
    "title": "Comparison: Effort vs Impact",
    "content": "| Artifact | Build difficulty | Audience | Frequency of use | Impact | . | Decision Table | Low | BA, QA, Developers | Per command, per review | ★★★★★ | . | Test Scenario Matrix | Low | QA, Developers | Per sprint, per feature | ★★★★★ | . | Validation Checklist | Very low | Client, Product Owner | Per milestone, sign-off | ★★★★☆ | . | Traceability Matrix | Medium | Compliance, Architects | Per release, per audit | ★★★★☆ | . | Topology Diagram | Low | Architects, New joiners | Per system change | ★★★☆☆ | . | Integration Manifest | Low | Architects, DevOps | Per integration planning | ★★★☆☆ | . | Command Catalog | Very low | Everyone | Reference, onboarding | ★★☆☆☆ | . ",
    "url": "/guide/example-artifacts.html#comparison-effort-vs-impact",
    
    "relUrl": "/guide/example-artifacts.html#comparison-effort-vs-impact"
  },"26": {
    "doc": "Example artifacts",
    "title": "Example artifacts",
    "content": " ",
    "url": "/guide/example-artifacts.html",
    
    "relUrl": "/guide/example-artifacts.html"
  },"27": {
    "doc": "Getting Started",
    "title": "Getting Started",
    "content": " ",
    "url": "/guide/getting-started.html",
    
    "relUrl": "/guide/getting-started.html"
  },"28": {
    "doc": "Getting Started",
    "title": "VS Code Setup",
    "content": ". | Install the YAML extension by Red Hat. | Add to your workspace .vscode/settings.json: . | . { \"yaml.schemas\": { \"https://mean-machine-gc.github.io/ubispec/schema/lifecycle.v1.0.schema.json\": \"*.lifecycle.ubispec.yaml\", \"https://mean-machine-gc.github.io/ubispec/schema/process.v1.0.schema.json\": \"*.process.ubispec.yaml\" } } . | Create a file ending in .lifecycle.ubispec.yaml or .process.ubispec.yaml. You get validation, autocomplete, and hover docs immediately. | . Alternatively, add a schema comment at the top of any file: . # yaml-language-server: $schema=https://mean-machine-gc.github.io/ubispec/schema/lifecycle.v1.0.schema.json . ",
    "url": "/guide/getting-started.html#vs-code-setup",
    
    "relUrl": "/guide/getting-started.html#vs-code-setup"
  },"29": {
    "doc": "Getting Started",
    "title": "Your First Lifecycle",
    "content": "Create order.lifecycle.ubispec.yaml: . ubispec: lifecycle/v1.0 decider: Order identity: orderId model: \"./model.ts\" lifecycle: - When: PlaceOrder actor: Customer And: - order-is-draft - has-lines - all-products-in-stock Then: OrderPlaced Outcome: - state-is-placed - placed-at-recorded - When: CancelOrder actor: Customer And: - is-cancellable Then: OrderCancelled Outcome: - state-is-cancelled . That’s a valid UbiSpec. No predicates needed. Read it out loud — anyone can confirm or challenge it. Adding Detail Incrementally . Start with names. Add scopes when you want to see the architecture. Add expressions when you’re ready to implement. # Level 1 — name only (domain pass) - order-is-draft # Level 2 — scope annotation (shows data source) - order-is-draft: dm.state # Level 3 — prose (documentation) - order-is-draft: \"Order must be in Draft status\" # Level 4 — expression (executable) - order-is-draft: \"dm.state.status.kind === 'Draft'\" . Mix levels freely. Some predicates at Level 4, others still at Level 1. That’s a legitimate intermediate state, not an incomplete spec. ",
    "url": "/guide/getting-started.html#your-first-lifecycle",
    
    "relUrl": "/guide/getting-started.html#your-first-lifecycle"
  },"30": {
    "doc": "Getting Started",
    "title": "Your First Process",
    "content": "Create order-fulfillment.process.ubispec.yaml: . ubispec: process/v1.0 process: OrderFulfillmentManager reacts_to: [Order] emits_to: [Inventory, Payment] model: \"./model.ts\" reactions: - When: OrderPlaced From: Order trigger: automated Then: - ReserveInventory -&gt; Inventory - InitiatePaymentCapture -&gt; Payment - When: OrderCancelled From: Order trigger: automated Then: - ReleaseInventory -&gt; Inventory - InitiateRefund -&gt; Payment: - payment-was-captured: rm.ctx . trigger: automated means the runtime executes these commands when the event arrives. Use trigger: policy for links that express a causal expectation but require human action: . - When: OrderFlagged From: Order trigger: policy actor: ReviewTeam Then: ReviewOrder -&gt; Order . ",
    "url": "/guide/getting-started.html#your-first-process",
    
    "relUrl": "/guide/getting-started.html#your-first-process"
  },"31": {
    "doc": "Getting Started",
    "title": "Using UbiSpec with LLM Agents",
    "content": "Point an agent at the spec index to discover the current format: . https://mean-machine-gc.github.io/ubispec/spec/index.json . Returns: . { \"specs\": { \"lifecycle\": { \"latest\": \"v1.0\", \"stable\": [\"v1.0\"], \"unstable\": [], \"schema\": \"https://mean-machine-gc.github.io/ubispec/schema/lifecycle.v1.0.schema.json\", \"spec\": \"https://mean-machine-gc.github.io/ubispec/spec/lifecycle/v1.0\" }, \"process\": { \"latest\": \"v1.0\", \"stable\": [\"v1.0\"], \"unstable\": [], \"schema\": \"https://mean-machine-gc.github.io/ubispec/schema/process.v1.0.schema.json\", \"spec\": \"https://mean-machine-gc.github.io/ubispec/spec/process/v1.0\" } } } . Agent Workflow . A typical agent prompt for generating UbiSpec from a domain conversation: . 1. Fetch https://mean-machine-gc.github.io/ubispec/spec/index.json 2. Fetch the latest lifecycle spec and schema 3. Given the following domain context: { ... } 4. Generate a lifecycle UbiSpec that validates against the schema . The schema is a standard JSON Schema. Any agent that can validate YAML against JSON Schema can produce and verify UbiSpec. Feeding Existing Specs to Agents . When asking an agent to work with your specs, provide: . Here is the UbiSpec format reference: { paste or link to spec page } Here is our current domain model: { paste model.ts } Here are our current specs: { paste *.ubispec.yaml files } Task: add a new command ReturnOrder to the Order lifecycle. The agent has the format, the types, and the existing behaviour. It can generate a spec entry that’s consistent with what exists. ",
    "url": "/guide/getting-started.html#using-ubispec-with-llm-agents",
    
    "relUrl": "/guide/getting-started.html#using-ubispec-with-llm-agents"
  },"32": {
    "doc": "Getting Started",
    "title": "Versioning",
    "content": "The ubispec: field in your YAML declares which version of the format you’re using: . ubispec: lifecycle/v1.0 # stable — guaranteed not to break ubispec: lifecycle/v1.1 # added optional fields, backward compatible ubispec: lifecycle/v2.0 # breaking structural changes . Minor bumps (v1.0 → v1.1) add optional fields. Your existing specs remain valid. Major bumps (v1 → v2) change required fields or structure. Your specs need migration. Match your schema URL to the version you’re using. The schema validates that your YAML conforms to that version’s structure. ",
    "url": "/guide/getting-started.html#versioning",
    
    "relUrl": "/guide/getting-started.html#versioning"
  },"33": {
    "doc": "Getting Started",
    "title": "Playground",
    "content": "Try the interactive playground to write specs in the browser with live visualization — topology graphs, decision tables, test scenarios, and validation checklists rendered as you type. ",
    "url": "/guide/getting-started.html#playground",
    
    "relUrl": "/guide/getting-started.html#playground"
  },"34": {
    "doc": "Getting Started",
    "title": "Next Steps",
    "content": ". | Read the Conceptual Foundations for why UbiSpec is shaped this way | Browse the Examples for complete lifecycle and process specs | Explore the Lifecycle spec and Process spec for the full format reference | . ",
    "url": "/guide/getting-started.html#next-steps",
    
    "relUrl": "/guide/getting-started.html#next-steps"
  },"35": {
    "doc": "Guide",
    "title": "Getting Started with UbiSpec",
    "content": "This guide walks through creating UbiSpec for a system, starting from domain discovery and ending with a structured specification that can generate user stories, test scenarios, and documentation. ",
    "url": "/guide/guide.html#getting-started-with-ubispec",
    
    "relUrl": "/guide/guide.html#getting-started-with-ubispec"
  },"36": {
    "doc": "Guide",
    "title": "Prerequisites",
    "content": "UbiSpec captures behaviour. Before writing specs, you need to understand the domain. This understanding can come from: . | Collaborative modelling sessions (EventStorming, Context Mapping, Example Mapping) | Domain conversations with experts and stakeholders | Exploratory prototyping — writing UbiSpec to surface questions | . The first two are recommended. The third works when you’re early in discovery and want to use the spec format itself as a thinking tool. ",
    "url": "/guide/guide.html#prerequisites",
    
    "relUrl": "/guide/guide.html#prerequisites"
  },"37": {
    "doc": "Guide",
    "title": "Two Entry Points",
    "content": "Entry A: You’ve Done Discovery . You’ve run EventStorming workshops or similar sessions. You have a sense of your bounded contexts, key aggregates, commands, events, and policies. You know what the major pieces are and roughly how they interact. Start here: Pick one aggregate. Write its Lifecycle UbiSpec. Move to the next. Then write Process UbiSpec for the coordination between them. Entry B: You’re Exploring . You have a domain to model but haven’t done formal discovery yet. Maybe it’s a greenfield project, or you’re trying to understand an existing system, or you’re in a conversation with a client. Start here: Pick the most important “thing” in the domain. Ask: what can happen to it? Write a rough lifecycle. The gaps and questions that surface become your discovery backlog — and you’ve already got a structured artifact to show for the conversation. Either way, the format is the same. The quality depends on the discovery, not the syntax. ",
    "url": "/guide/guide.html#two-entry-points",
    
    "relUrl": "/guide/guide.html#two-entry-points"
  },"38": {
    "doc": "Guide",
    "title": "Step 1: Identify Your Aggregate",
    "content": "An aggregate is a “thing” that has a lifecycle — it gets created, moves through states, and eventually reaches a terminal state. It enforces its own rules. Ask: What are the key nouns in this domain that have rules governing what can happen to them? . Examples: . | An Order that gets created, placed, confirmed, shipped, delivered, or cancelled | A Registry that gets drafted, submitted for review, approved or rejected | A Laboratory that gets registered, activated, suspended, reinstated, or closed | A Claim that gets filed, assessed, approved, paid, or disputed | . Pick one. Start there. ",
    "url": "/guide/guide.html#step-1-identify-your-aggregate",
    
    "relUrl": "/guide/guide.html#step-1-identify-your-aggregate"
  },"39": {
    "doc": "Guide",
    "title": "Step 2: Discover the Lifecycle States",
    "content": "Ask the domain expert: What states can this thing be in? . Draw them out. Find the transitions. Identify: . | The initial state (what does it look like right after creation?) | The terminal states (what’s the end of the road?) | Any loops (can it go back to a previous state?) | . Order: Draft → Placed → Confirmed → Shipped → Delivered ↓ ↓ Cancelled RefundRequested . ",
    "url": "/guide/guide.html#step-2-discover-the-lifecycle-states",
    
    "relUrl": "/guide/guide.html#step-2-discover-the-lifecycle-states"
  },"40": {
    "doc": "Guide",
    "title": "Step 3: Discover Commands Per State",
    "content": "For each state, ask: What can happen to it when it’s in this state? . Each answer is a command. For each command, ask: . | Who initiates it? (A user role, another system, a scheduled job?) | What information do they provide? | What must be true for it to succeed? | What changes as a result? | . Don’t try to be exhaustive on the first pass. Capture the main paths. You’ll discover edge cases as you write. ",
    "url": "/guide/guide.html#step-3-discover-commands-per-state",
    
    "relUrl": "/guide/guide.html#step-3-discover-commands-per-state"
  },"41": {
    "doc": "Guide",
    "title": "Step 4: Write the Lifecycle UbiSpec (Names Only)",
    "content": "Start with names only. No predicates. This is the domain pass — meant to be validated by anyone in the room. Create a file: order.lifecycle.ubispec.yaml . bspec: lifecycle/v1 decider: Order identity: orderId model: \"./model.ts\" lifecycle: - When: CreateOrder And: - valid-customer Then: OrderCreated Outcome: - state-is-draft - customer-set - no-lines - When: AddLineItem And: - order-is-draft - product-exists - positive-quantity Then: LineItemAdded Outcome: - line-present - lines-grew - status-unchanged - When: PlaceOrder And: - order-is-draft - has-lines - all-products-in-stock Then: - OrderPlaced - HighValueOrderFlagged: - high-value Outcome: _always: - state-is-placed - placed-at-recorded HighValueOrderFlagged: - requires-manual-review - When: CancelOrder And: - is-cancellable - has-reason Then: - OrderCancelled - InventoryReleased: - had-reservation Outcome: _always: - state-is-cancelled - reason-recorded . This is already a complete specification. Read it out loud in a meeting. Does the domain expert agree that: . | Creating an order requires a valid customer? | Placing an order requires at least one line and all products in stock? | A high-value order gets flagged for manual review? | Cancellation releases inventory only if it was reserved? | . If yes, you’ve captured behaviour. If no, revise. The YAML structure forces precision that prose allows you to dodge. ",
    "url": "/guide/guide.html#step-4-write-the-lifecycle-ubispec-names-only",
    
    "relUrl": "/guide/guide.html#step-4-write-the-lifecycle-ubispec-names-only"
  },"42": {
    "doc": "Guide",
    "title": "Step 5: Validate and Iterate",
    "content": "Walk through each command with stakeholders. Common discoveries at this stage: . | Missing states: “Oh, an order can also be On Hold if payment verification is pending.” | Missing constraints: “Actually, you can only cancel before it ships.” | Missing outcomes: “When we cancel, we also need to notify the customer.” | Wrong assumptions: “High value isn’t just about price — it’s also about the customer’s risk rating.” | . Update the spec. Each revision is a conversation turn captured in structure. The spec becomes the shared memory of what was decided and why. ",
    "url": "/guide/guide.html#step-5-validate-and-iterate",
    
    "relUrl": "/guide/guide.html#step-5-validate-and-iterate"
  },"43": {
    "doc": "Guide",
    "title": "Step 6: Discover Cross-Aggregate Coordination",
    "content": "Once you have two or more lifecycles, ask: When this event happens on aggregate A, does anything need to happen on aggregate B? . Walk through every event. Most won’t trigger anything. Some will. Those are your Process UbiSpec. Create a file: order-fulfillment.process.ubispec.yaml . bspec: process/v1 process: OrderFulfillmentManager reacts_to: [Order] emits_to: [Inventory, Payment, Notification] reactions: - When: OrderPlaced From: Order Then: - ReserveInventory -&gt; Inventory - InitiatePaymentCapture -&gt; Payment - When: OrderCancelled From: Order Then: - ReleaseInventory -&gt; Inventory - InitiateRefund -&gt; Payment: - payment-was-captured - SendNotification -&gt; Notification . This reveals the system topology — which aggregates talk to each other and through what events. It’s the wiring diagram of your system, derived from behaviour, not drawn on a whiteboard. ",
    "url": "/guide/guide.html#step-6-discover-cross-aggregate-coordination",
    
    "relUrl": "/guide/guide.html#step-6-discover-cross-aggregate-coordination"
  },"44": {
    "doc": "Guide",
    "title": "Step 7: Generate Artifacts",
    "content": "From the names-only UbiSpec, you can already generate: . User Stories . Each command entry generates a story: . As a customer I can place an order Given the order is in draft, has lines, and all products are in stock So that the order is placed and the timestamp is recorded And if the order is high value, it is flagged for manual review . Acceptance Criteria . Each constraint becomes a criterion: . | Order must be in Draft status | Order must have at least one line item | All products must be in stock | After placement, status is Placed | Placed timestamp is recorded | If order total exceeds threshold, manual review flag is set | . Test Scenarios . Each constraint generates a success and failure scenario: . ✅ Place order with valid lines, all in stock → OrderPlaced ✅ Place high-value order → OrderPlaced + HighValueOrderFlagged ❌ Place order with no lines → DecisionFailed [has-lines] ❌ Place order with out-of-stock product → DecisionFailed [all-products-in-stock] ❌ Place order that’s already placed → DecisionFailed [order-is-draft] . Workflow Documentation . The process specs generate coordination flows: . When OrderPlaced occurs: → Reserve inventory (Inventory) → Initiate payment capture (Payment) . When OrderCancelled occurs: → Release inventory (Inventory) → Initiate refund (Payment) only if payment was captured → Send cancellation notification (Notification) . All of this is mechanical transformation of the YAML structure. No predicates needed. ",
    "url": "/guide/guide.html#step-7-generate-artifacts",
    
    "relUrl": "/guide/guide.html#step-7-generate-artifacts"
  },"45": {
    "doc": "Guide",
    "title": "Step 8: Add Predicates (When Ready)",
    "content": "When the team moves to implementation, add executable expressions to each name: . - When: PlaceOrder And: - order-is-draft: \"dm.state.status.kind === 'Draft'\" - has-lines: \"dm.state.lines.length &gt; 0\" - all-products-in-stock: \"dm.ctx.allInStock\" # shell: InventoryService.checkAll(dm.state.lines) Then: - OrderPlaced - HighValueOrderFlagged: - high-value: \"dm.ctx.orderTotal &gt; 10000\" # shell: PricingService.calculateTotal(dm.state.lines) Outcome: _always: - state-is-placed: \"om.state.status.kind === 'Placed'\" - placed-at-recorded: \"om.state.status.placedAt != null\" HighValueOrderFlagged: - requires-manual-review: \"om.state.requiresManualReview === true\" . Now the spec can generate executable tests, implementation skeletons, and integration point manifests (every dm.ctx reference is a service dependency). This is a different pass by different people. The structure doesn’t change. The names don’t change. The domain expert validated the names. The developer fills in the expressions. ",
    "url": "/guide/guide.html#step-8-add-predicates-when-ready",
    
    "relUrl": "/guide/guide.html#step-8-add-predicates-when-ready"
  },"46": {
    "doc": "Guide",
    "title": "Tips",
    "content": "Start small. One aggregate, five or six commands. Get the pattern right before scaling. Names matter more than expressions. A good name (reviewer-is-authorised) communicates intent even without a predicate. A bad name (check-3) communicates nothing even with one. Outcomes are assertions, not steps. Don’t describe how the state changes. Describe what must be true after. “state-is-active” not “set status to active.” . Assert what doesn’t change. If placing an order shouldn’t modify the customer ID, say so: customer-unchanged. The negative space catches bugs that positive assertions miss. Let the Process UbiSpec reveal architecture. Don’t design the coordination up front. Write the lifecycles first. Then ask “what needs to react to this event?” The topology emerges. Revisit after implementation. Once code exists, the spec becomes a living contract. If the code can’t satisfy an outcome assertion, either the code has a bug or the spec has a wrong assumption. Either way, the conversation is productive. ",
    "url": "/guide/guide.html#tips",
    
    "relUrl": "/guide/guide.html#tips"
  },"47": {
    "doc": "Guide",
    "title": "What UbiSpec Gives You",
    "content": "From a single source of truth, at each level of predicate detail: . | Output | Names only | + Scopes | + Expressions | . | Structured behaviour catalog | ✓ | ✓ | ✓ | . | User stories with acceptance criteria | ✓ | ✓ | ✓ | . | Test scenarios and coverage matrices | ✓ | ✓ | ✓ | . | Workflow documentation | ✓ | ✓ | ✓ | . | Client validation checklists | ✓ | ✓ | ✓ | . | Shell / integration point manifests |   | ✓ | ✓ | . | Data flow architecture |   | ✓ | ✓ | . | Executable test suites |   |   | ✓ | . | Implementation skeletons |   |   | ✓ | . The first column requires zero code. A UbiSpec with names only is already a complete behavioural specification — structured enough to generate documentation and stories, precise enough to validate with stakeholders. Adding scope annotations (dm.state, dm.ctx) reveals the architecture. Adding expressions makes it executable. ",
    "url": "/guide/guide.html#what-ubispec-gives-you",
    
    "relUrl": "/guide/guide.html#what-ubispec-gives-you"
  },"48": {
    "doc": "Guide",
    "title": "Where UbiSpec Fits",
    "content": "UbiSpec operationalises the output of collaborative modelling. It’s not a replacement for domain discovery — it’s what you write after discovery, to capture what you learned in a format that survives. Starting From Collaborative Modelling . If you’ve done EventStorming, Context Mapping, Example Mapping, or similar workshops, you already have the raw material: bounded contexts, aggregates, commands, events, policies, read models. UbiSpec gives that material a structured home: . EventStorming / Context Mapping / Domain Conversations ↓ Bounded contexts identified, aggregates sketched ↓ UbiSpec (one Lifecycle per aggregate, one Process per coordination flow) ↓ ├→ Validation with domain experts (names pass) ├→ User stories, test scenarios, documentation ├→ Enrichment with predicates (developer pass) └→ Implementation, executable tests . The workshop gives you the big picture — contexts, boundaries, flows. UbiSpec zooms into each aggregate and captures the precise rules: which commands are accepted, under what conditions, what changes, what doesn’t. Starting From Scratch . If there’s no prior modelling, UbiSpec can be used as a discovery tool. Writing specs forces the questions that matter: What can happen to this thing? When can it happen? What prevents it? What changes as a result? What must stay the same? . Start with one aggregate. Write the lifecycle. Present it. The gaps and contradictions surface quickly — “wait, can a suspended lab be closed directly?” — because the structure demands answers the way prose doesn’t. As you write more aggregates, cross-cutting coordination surfaces naturally: “when this event happens on aggregate A, does anything need to happen on aggregate B?” That’s a Process UbiSpec. The topology of your system emerges from the specs. This works especially well when prototyping: sketch a few lifecycles, see how they interact, refactor boundaries. UbiSpec are cheap to rewrite because they’re small and self-contained. Either Way . Whether you start from a week-long EventStorming or a single conversation, UbiSpec captures the output in the same format. The quality of the specs depends on the quality of the discovery — but the format ensures that whatever you discover doesn’t evaporate. ",
    "url": "/guide/guide.html#where-ubispec-fits",
    
    "relUrl": "/guide/guide.html#where-ubispec-fits"
  },"49": {
    "doc": "Guide",
    "title": "Guide",
    "content": " ",
    "url": "/guide/guide.html",
    
    "relUrl": "/guide/guide.html"
  },"50": {
    "doc": "Examples",
    "title": "Examples",
    "content": "Complete UbiSpec examples across different domains, demonstrating that the format is general-purpose. ",
    "url": "/examples/",
    
    "relUrl": "/examples/"
  },"51": {
    "doc": "Examples",
    "title": "E-commerce Order",
    "content": "A familiar domain: orders that move through a lifecycle from draft to delivery, with fulfillment coordination across inventory, payment, and notification systems. Files: . | order.lifecycle.ubispec.yaml — Order aggregate lifecycle (create, add lines, place, confirm, ship, deliver, cancel, refund) | order-fulfillment.process.ubispec.yaml — Fulfillment coordination (inventory reservation, payment capture, notifications) | model.ts — TypeScript domain model | . Patterns demonstrated: . | Single unconditional events (OrderCreated, LineItemAdded) | Additive events: base + conditional (OrderPlaced + HighValueOrderFlagged) | all trigger: cross-aggregate join (PaymentConfirmed + InventoryReserved → ScheduleShipment) | Conditional commands with context queries (InitiateRefund only if payment captured) | Cross-aggregate coordination with ordering constraints | . ",
    "url": "/examples/#e-commerce-order",
    
    "relUrl": "/examples/#e-commerce-order"
  },"52": {
    "doc": "Examples",
    "title": "Laboratory Capability Framework",
    "content": "A governance domain: laboratories undergo capability assessment against a national registry, with assignments tracked through review and confirmation workflows. Files: . | laboratory.lifecycle.ubispec.yaml — Laboratory aggregate lifecycle (register, activate, suspend, assign profiles, update assignments) | assessment-lifecycle.process.ubispec.yaml — Assessment coordination (submission → review → confirmation/adjustment) | . Patterns demonstrated: . | any trigger: [AssessmentSubmittedFullyMet, AssessmentSubmittedWithGaps] on one reaction | Ordered command sequences: withdraw then assign | Conditional commands based on read-model context (rm.ctx) | Discriminated union narrowing with rm.event.kind | . ",
    "url": "/examples/#laboratory-capability-framework",
    
    "relUrl": "/examples/#laboratory-capability-framework"
  },"53": {
    "doc": "Lifecycle UbiSpec",
    "title": "Lifecycle UbiSpec",
    "content": "Behavioural Specification Format for Event-Sourced Aggregate Deciders . Version: 0.2.0 Part of: UbiSpec (Behavioural Specification Format for Software Systems) . ",
    "url": "/spec/lifecycle.html",
    
    "relUrl": "/spec/lifecycle.html"
  },"54": {
    "doc": "Lifecycle UbiSpec",
    "title": "1. Purpose",
    "content": "A Lifecycle UbiSpec describes the complete behavioural contract of an event-sourced aggregate decider. It captures: . | Which commands the aggregate accepts | Under what conditions each command is accepted or rejected | Which events each command produces on success | What must be true after those events are applied | . The spec is both human-readable (constraint names are natural language) and machine-executable (predicates are TypeScript expressions). It serves simultaneously as a domain conversation artifact, a test suite, and an implementation contract. A Lifecycle UbiSpec only describes success paths. Failure handling is implicit (§9). ",
    "url": "/spec/lifecycle.html#1-purpose",
    
    "relUrl": "/spec/lifecycle.html#1-purpose"
  },"55": {
    "doc": "Lifecycle UbiSpec",
    "title": "2. Scope",
    "content": "One Lifecycle UbiSpec per aggregate. Cross-aggregate coordination is specified separately in a Process UbiSpec. ",
    "url": "/spec/lifecycle.html#2-scope",
    
    "relUrl": "/spec/lifecycle.html#2-scope"
  },"56": {
    "doc": "Lifecycle UbiSpec",
    "title": "3. Relationship to Model",
    "content": "A Lifecycle UbiSpec references a TypeScript model file that defines all domain types. The model is the type authority. The spec is the behaviour authority. The spec does not define types. ",
    "url": "/spec/lifecycle.html#3-relationship-to-model",
    
    "relUrl": "/spec/lifecycle.html#3-relationship-to-model"
  },"57": {
    "doc": "Lifecycle UbiSpec",
    "title": "4. Document Structure",
    "content": "bspec: lifecycle/v1 decider: &lt;AggregateName&gt; identity: &lt;identityFieldName&gt; model: &lt;path to TypeScript model file&gt; common: &lt;predicate-name&gt;: &lt;expression&gt; lifecycle: - When: &lt;CommandName&gt; And: [...] Then: &lt;event specification&gt; Outcome: &lt;assertions&gt; . 4.1 Header . | Field | Required | Description | . | bspec | Yes | Format identifier. Must be lifecycle/v1. | . | decider | Yes | Aggregate name. PascalCase. | . | identity | Yes | Field that uniquely identifies aggregate instances. | . | model | Yes | Relative path to the TypeScript model file. | . 4.2 Common . common: &lt;predicate-name&gt;: &lt;expression&gt; . Optional. Reusable predicates referenced by bare name in And blocks. Each entry is a kebab-case name and a TypeScript boolean expression. ",
    "url": "/spec/lifecycle.html#4-document-structure",
    
    "relUrl": "/spec/lifecycle.html#4-document-structure"
  },"58": {
    "doc": "Lifecycle UbiSpec",
    "title": "5. Decision",
    "content": "Each element under lifecycle specifies one decision — the complete behaviour for one command, from acceptance through outcome. lifecycle: - When: &lt;CommandName&gt; And: &lt;constraints&gt; Then: &lt;events&gt; Outcome: &lt;assertions&gt; . 5.1 When . When: &lt;CommandName&gt; . Names the command. One decision per command. PascalCase, must match a type in the model. 5.2 And — Constraints . And: - &lt;constraint-name&gt;: &lt;expression&gt; - &lt;constraint-name&gt; . Constraints that must all hold for the command to succeed. If any constraint fails, the command produces a DecisionFailed event (§9) and no success events. Each entry is one of: . | Inline: name: expression — name is natural language, expression is executable. | Common reference: name (bare, no value) — resolved from common. | . Constraints are evaluated against the Decision Model (§7). And is optional. A command with no constraints always succeeds. 5.3 Then — Events . Specifies which events are produced on success. A command can produce one or more events. Scalar Form . Then: &lt;EventName&gt; . Shorthand. The command produces exactly this one event, unconditionally. List Form . Then: - &lt;EventName&gt; - &lt;EventName&gt;: - &lt;condition-name&gt;: &lt;expression&gt; - &lt;EventName&gt; . Each entry is an event that may or may not be emitted: . | Unconditional event: bare event name. Always emitted on success. | Conditional event: event name with a list of name: expression conditions. Emitted only when all conditions hold. | . Rules: . | All qualifying events are emitted. Every unconditional event fires. Every conditional event whose conditions all pass fires. This is not first-match-wins — it is additive. | Conditions are evaluated against the Decision Model (§7), same as constraints. | At least one event must be emitted on success. If all events are conditional and none match, this is a spec error (the constraints should have prevented this state). | Events are emitted in list order. Order may matter for evolve. | . Patterns . Single unconditional event (most common): . Then: TestEntryAdded . Multiple unconditional events (batch): . Then: - LaboratoryRegistered - AuditTrailCreated . Base event plus conditional extras (additive): . Then: - RegistryApproved - PreviousRegistryArchived: - has-active-registry: \"dm.ctx.currentActiveRegistryId != null\" . Mutually exclusive events (alternative — predicates ensure exclusivity): . Then: - AssessmentSubmittedFullyMet: - fully-met: \"dm.ctx.overallResult === 'FullyMet'\" - AssessmentSubmittedWithGaps: - has-gaps: \"dm.ctx.overallResult !== 'FullyMet'\" . Mixed: . Then: - RegistryApproved - PreviousRegistryArchived: - has-active-registry: \"dm.ctx.currentActiveRegistryId != null\" - TransitionPeriodStarted: - has-transition-period: \"dm.cmd.transitionDays &gt; 0\" . 5.4 Outcome — Assertions . Specifies what must be true after all emitted events have been applied (after evolve). Two forms: . Flat Form . Outcome: - &lt;assertion-name&gt;: &lt;expression&gt; - &lt;assertion-name&gt;: &lt;expression&gt; . A flat list. All assertions must hold after evolve. Use this when: . | Then is scalar (single event), or | All assertions apply regardless of which conditional events fired. | . Keyed Form . Outcome: _always: - &lt;assertion-name&gt;: &lt;expression&gt; &lt;EventName&gt;: - &lt;assertion-name&gt;: &lt;expression&gt; &lt;EventName&gt;: - &lt;assertion-name&gt;: &lt;expression&gt; . Assertions grouped by relevance: . | _always: assertions that hold after every successful execution, regardless of which events were emitted. | Event-keyed sections: assertions that are evaluated only when that event was emitted. If the event’s conditions didn’t fire, its outcome section is skipped. | . Rules: . | _always is optional. If present, it runs on every success. | Event keys must match event names from Then. | All assertions (both _always and event-specific) are evaluated against the final state after all emitted events have been evolved, in order. | Assertions use the Outcome Model (§8). | . Flat form is syntactic shorthand — it is equivalent to putting all assertions in _always. ",
    "url": "/spec/lifecycle.html#5-decision",
    
    "relUrl": "/spec/lifecycle.html#5-decision"
  },"59": {
    "doc": "Lifecycle UbiSpec",
    "title": "6. Predicate Entry",
    "content": "The atomic element of the spec. Appears in common, And, Then conditions, and Outcome. 6.1 Naming . Every predicate has a name — a kebab-case identifier that reads as natural language. The name is the specification. It carries the meaning across all audiences. | Constraints: registry-is-draft, reviewer-is-authorised, entry-exists-in-catalog | Conditions: has-active-registry, is-sampling-activity, has-downstream-refs | Assertions: state-is-active, entry-in-catalog, catalog-unchanged | . 6.2 Detail Levels . The value of a predicate — the part after the colon — can take four forms, from least to most precise. All four are valid UbiSpec. They represent a spectrum, not a hierarchy. Use the level that fits your stage and audience. Level 1: Name Only . - registry-is-draft . The constraint exists. The name says what it means. No further detail. This is the form used in the domain pass — the first pass where domain experts validate the behavioural logic. A specification with only Level 1 predicates is already a complete behavioural contract: it captures what commands exist, what conditions apply, what events are produced, and what outcomes are asserted. Level 2: Scope Annotation . - registry-is-draft: dm.state - reviewer-is-authorised: dm.ctx - entry-matches-area: [dm.cmd, dm.state] - state-is-active: om.state - event-carries-effective-date: [om.evts, dm.cmd] . The predicate names which data sources are involved, without specifying how they are evaluated. This tells you: . | dm.state — the constraint depends only on the aggregate’s current state. | dm.ctx — the constraint requires an external lookup (an async shell dependency). | [dm.cmd, dm.state] — the constraint compares the command payload against current state. | om.state — the assertion checks the new state after evolve. | [om.evts, dm.cmd] — the assertion verifies that event payloads carry data from the command. | . Scope annotations are language-agnostic. They work whether you’re implementing in TypeScript, Kotlin, F#, or describing the system in a document. They already provide architectural information: you know which constraints are pure (dm.state, dm.cmd), which require the shell (dm.ctx), and which assertions compare before/after state (om.state vs dm.state). Level 3: Prose Description . - registry-is-draft: \"Registry must be in Draft status\" - reviewer-is-authorised: \"The reviewer must be a national authority (dm.ctx)\" - entry-matches-area: \"The submitted entry's area must match the registry's area (dm.cmd, dm.state)\" . The predicate describes the rule in natural language. Optionally annotates with scope. This is useful for teams that want specifications readable as documentation but aren’t ready or don’t need to write code expressions. The parenthetical scope annotation preserves the architectural information. Level 4: Executable Expression . - registry-is-draft: \"dm.state.status.kind === 'Draft'\" - reviewer-is-authorised: \"dm.ctx.isNationalAuthority\" - entry-matches-area: \"dm.cmd.area.kind === dm.state.area.kind\" . The predicate is a boolean expression evaluable against the domain model. This is the most precise form — it can be validated against the model, used to generate tests, and used to generate implementation. Expressions must: . | Reference only dm.* or om.* namespaces | Be pure (no side effects, no variables, no async) | Use ?. for optional fields, ?? default for safe defaults | . The expression language used in this specification is TypeScript, chosen because it is widely readable and because it matches the domain model format. The UbiSpec structure (names, namespaces, When/And/Then/Outcome) is language-agnostic. Teams working in other languages can write expressions in their own syntax while using the same namespaces and the same specification structure. 6.3 Mixing Levels . Levels can be mixed within a single spec. This is expected and encouraged — it reflects the natural state of evolving specifications: . - When: ApproveRegistry And: - registry-is-submitted: \"dm.state.status.kind === 'SubmittedForReview'\" # Level 4 - reviewer-is-authorised: dm.ctx # Level 2 - no-unresolved-comments # Level 1 Then: - RegistryApproved - PreviousRegistryArchived: - has-active-registry: \"dm.ctx.currentActiveRegistryId != null\" # Level 4 Outcome: _always: - state-is-active: \"om.state.status.kind === 'Active'\" # Level 4 - effective-date-set: [om.state, dm.cmd] # Level 2 PreviousRegistryArchived: - archival-target-correct: \"Previous registry's ID matches context\" # Level 3 . This spec is incomplete from an execution standpoint but complete from a behavioural standpoint. Every constraint is named. Most have scope or expressions. One is still prose. This is a legitimate intermediate state — and in practice, most specifications live here for a while. 6.4 Common Predicates . Reusable predicates defined once in the common section: . common: registry-is-draft: \"dm.state.status.kind === 'Draft'\" registry-is-submitted: \"dm.state.status.kind === 'SubmittedForReview'\" . Referenced by bare name: . And: - registry-is-draft - valid-name: \"dm.cmd.name.length &gt; 0\" . Common predicates can also use any detail level. A common predicate at Level 2 (registry-is-draft: dm.state) tells every consumer of that predicate which data source is involved. ",
    "url": "/spec/lifecycle.html#6-predicate-entry",
    
    "relUrl": "/spec/lifecycle.html#6-predicate-entry"
  },"60": {
    "doc": "Lifecycle UbiSpec",
    "title": "7. Decision Model (dm)",
    "content": "The input context for constraints and event conditions. 7.1 dm.cmd — Command Payload . - valid-name: \"dm.cmd.name.length &gt; 0\" - entry-id-unique: \"!(dm.cmd.entryId in dm.state.testCatalog)\" . 7.2 dm.state — Current State (before) . - registry-is-draft: \"dm.state.status.kind === 'Draft'\" - has-profiles: \"Object.keys(dm.state.profiles).length &gt; 0\" . 7.3 dm.ctx — Shell-Resolved Context . Async context resolved before decide runs. Every dm.ctx reference is a shell contract. - reviewer-is-authorised: \"dm.ctx.isNationalAuthority\" # shell: AuthorityService.check(dm.cmd.reviewedBy) - facility-exists: \"dm.ctx.facilityExists\" # shell: FacilityRegistry.lookup(dm.cmd.facilityRegistryId) . Convention: annotate with # shell: &lt;resolution hint&gt; on first use. Rule: context must never carry information derivable from dm.state. 7.4 Derivations . From a Lifecycle UbiSpec, an agent can mechanically derive: . | Context type per command: scan all dm.ctx.* references → generate TypeScript type. | Shell function per command: one async function per command with context dependencies. | Command types: verify dm.cmd.* paths against the model. | . ",
    "url": "/spec/lifecycle.html#7-decision-model-dm",
    
    "relUrl": "/spec/lifecycle.html#7-decision-model-dm"
  },"61": {
    "doc": "Lifecycle UbiSpec",
    "title": "8. Outcome Model (om)",
    "content": "The context for postcondition assertions. 8.1 om.state — State After Evolve . The aggregate state after all emitted events have been evolved, in order. - state-is-active: \"om.state.status.kind === 'Active'\" - entry-in-catalog: \"dm.cmd.entryId in om.state.testCatalog\" . 8.2 om.evts — Emitted Events . The list of events produced by the decide function, in emission order. - archival-event-present: &gt; om.evts.some(e =&gt; e.kind === 'PreviousRegistryArchived') - event-count: \"om.evts.length === 2\" - event-carries-data: &gt; om.evts.find(e =&gt; e.kind === 'RegistryApproved') .effectiveDate === dm.cmd.effectiveDate . 8.3 Cross-Model Access . Outcome assertions can reference both models: . | Namespace | Purpose | . | om.state | New state — what changed | . | om.evts | Emitted events — what happened | . | dm.state | Old state — before/after comparison | . | dm.cmd | Original command — payload verification | . | dm.ctx | Resolved context — cross-referencing | . # Before/after comparison - catalog-grew: &gt; Object.keys(om.state.testCatalog).length === Object.keys(dm.state.testCatalog).length + 1 # Payload verification - event-carries-entry-id: &gt; om.evts.find(e =&gt; e.kind === 'TestEntryAdded') .entryId === dm.cmd.entryId . 8.4 Outcome Completeness . A thorough Outcome includes: . | Positive — what changed (state transitions, field values) | Negative — what must NOT change (unrelated state preserved) | Event payload — events carry correct data from command/context | Event composition — correct events were emitted (count, presence) | . ",
    "url": "/spec/lifecycle.html#8-outcome-model-om",
    
    "relUrl": "/spec/lifecycle.html#8-outcome-model-om"
  },"62": {
    "doc": "Lifecycle UbiSpec",
    "title": "9. Implicit Failure Convention",
    "content": "A Lifecycle UbiSpec only describes success paths. Failure is handled by convention. 9.1 The DecisionFailed Event . When any constraint in And fails, the decide function emits a single event: . { kind: 'DecisionFailed', decision: string, // the command name from When failed: string[], // names of constraints that failed } . No other events are emitted. The evolve function does not modify state for DecisionFailed — the aggregate is unchanged. 9.2 Why This Works . | Every constraint has a name that reads as natural language. The failure payload is human-readable: { decision: \"ApproveRegistry\", failed: [\"reviewer-is-authorised\"] }. | The spec doesn’t need to enumerate failure events per command. The constraint names are the failure specification. | Test generation for failures is mechanical: for each constraint, construct a state/command/context that violates it, assert DecisionFailed with that constraint name. | UI error handling maps directly: the failed array tells the frontend which fields or conditions to highlight. | . 9.3 Implementation . The decide function follows this pattern: . function decide(cmd, state, ctx): Event[] { // 1. Evaluate all And constraints const failed = evaluateConstraints(cmd, state, ctx); if (failed.length &gt; 0) { return [{ kind: 'DecisionFailed', decision: cmd.type, failed }]; } // 2. Evaluate Then conditions and emit qualifying events const events = []; // ... for each event in Then, check conditions, push if pass return events; } . 9.4 DecisionFailed and Evolve . The evolve function must handle DecisionFailed: . function evolve(state, event): State { if (event.kind === 'DecisionFailed') return state; // no-op // ... normal event handling } . This is the only event that does not change state. It exists so that: . | The event stream records that a command was attempted and rejected (audit trail) | Subscribers (including the UI) can observe failures | The pattern stays consistent: every command produces at least one event | . ",
    "url": "/spec/lifecycle.html#9-implicit-failure-convention",
    
    "relUrl": "/spec/lifecycle.html#9-implicit-failure-convention"
  },"63": {
    "doc": "Lifecycle UbiSpec",
    "title": "10. Interpretation",
    "content": "10.1 As a Decision Table . Each decision is a row: . | Command | Constraints (all pass?) | Events (all matching) | Assertions (all hold) | . | When | And | Then | Outcome | . | (fail) | (any fail) | DecisionFailed | (state unchanged) | . 10.2 As Test Cases . Each decision generates: . | Success path: given (state, cmd, ctx) satisfying all constraints, when decide + evolve, then all qualifying events are emitted and all outcome assertions hold. | Per-constraint failure: for each constraint, given a violation, assert DecisionFailed with that constraint name and state unchanged. | Conditional event coverage: for each conditional event, test with conditions met (event present) and not met (event absent). | Event composition: when multiple events can fire, test all valid combinations. | Property-based: given any (state, cmd, ctx) satisfying all constraints, outcome assertions hold. | . 10.3 As Implementation Contract . | decide function: constraints → guard. Then conditions → event selection. All qualifying events emitted. | evolve function: must produce state satisfying all outcome assertions after processing events in order. | shell function: derived from dm.ctx references. One per command with context dependencies. | DecisionFailed handler: mechanical, same for all aggregates. | . ",
    "url": "/spec/lifecycle.html#10-interpretation",
    
    "relUrl": "/spec/lifecycle.html#10-interpretation"
  },"64": {
    "doc": "Lifecycle UbiSpec",
    "title": "11. Complete Example",
    "content": "bspec: lifecycle/v1 decider: Registry identity: registryId model: \"./model.ts\" common: registry-is-draft: \"dm.state.status.kind === 'Draft'\" registry-is-submitted: \"dm.state.status.kind === 'SubmittedForReview'\" lifecycle: # ── Simple: one unconditional event ── - When: CreateRegistry And: - no-existing-draft: \"!dm.ctx.existingDraftId\" # shell: RegistryRepo.findDraftId() Then: RegistryCreated Outcome: - state-is-draft: \"om.state.status.kind === 'Draft'\" - empty-catalog: \"Object.keys(om.state.testCatalog).length === 0\" - empty-capabilities: \"Object.keys(om.state.capabilities).length === 0\" - empty-profiles: \"Object.keys(om.state.profiles).length === 0\" - When: AddTestEntry And: - registry-is-draft - entry-id-unique: \"!(dm.cmd.entryId in dm.state.testCatalog)\" Then: TestEntryAdded Outcome: - entry-in-catalog: \"dm.cmd.entryId in om.state.testCatalog\" - catalog-grew: &gt; Object.keys(om.state.testCatalog).length === Object.keys(dm.state.testCatalog).length + 1 - capabilities-unchanged: &gt; Object.keys(om.state.capabilities).length === Object.keys(dm.state.capabilities).length - When: SubmitForReview And: - registry-is-draft - has-profiles: \"Object.keys(dm.state.profiles).length &gt; 0\" - all-capability-refs-valid: &gt; Object.values(dm.state.profiles).every(p =&gt; p.requiredCapabilities.every(ref =&gt; ref.id in dm.state.capabilities)) - all-entry-refs-valid: &gt; Object.values(dm.state.capabilities) .flatMap(c =&gt; c.entries ?? []) .every(ref =&gt; ref.id in dm.state.testCatalog) Then: RegistrySubmittedForReview Outcome: - state-is-submitted: \"om.state.status.kind === 'SubmittedForReview'\" - submitted-date-recorded: \"om.state.status.submittedDate != null\" - catalog-unchanged: &gt; Object.keys(om.state.testCatalog).length === Object.keys(dm.state.testCatalog).length # ── Additive: base event plus conditional extra ── - When: ApproveRegistry And: - registry-is-submitted - reviewer-is-authorised: \"dm.ctx.isNationalAuthority\" # shell: AuthorityService.check(dm.cmd.reviewedBy) Then: - RegistryApproved - PreviousRegistryArchived: - has-active-registry: \"dm.ctx.currentActiveRegistryId != null\" # shell: RegistryRepo.findActiveId() Outcome: _always: - state-is-active: \"om.state.status.kind === 'Active'\" - effective-date-set: \"om.state.status.effectiveDate === dm.cmd.effectiveDate\" - approval-event-carries-data: &gt; om.evts.find(e =&gt; e.kind === 'RegistryApproved') .effectiveDate === dm.cmd.effectiveDate PreviousRegistryArchived: - archival-target-correct: &gt; om.evts.find(e =&gt; e.kind === 'PreviousRegistryArchived') .registryId === dm.ctx.currentActiveRegistryId - archival-superseded-by-self: &gt; om.evts.find(e =&gt; e.kind === 'PreviousRegistryArchived') .supersededBy === dm.state.registryId - When: RejectRegistry And: - registry-is-submitted - reviewer-is-authorised: \"dm.ctx.isNationalAuthority\" - has-reason: \"dm.cmd.reason.length &gt; 0\" Then: RegistryRejected Outcome: - state-is-draft: \"om.state.status.kind === 'Draft'\" - rejection-carries-reason: &gt; om.evts.find(e =&gt; e.kind === 'RegistryRejected') .reason === dm.cmd.reason # ── Alternative: mutually exclusive events ── - When: SubmitAssessment And: - assessment-in-progress: \"dm.state.status.kind === 'InProgress'\" - all-requirements-responded: \"dm.ctx.allRequirementsResponded\" # shell: completeness check Then: - AssessmentSubmittedFullyMet: - fully-met: \"dm.ctx.overallResult === 'FullyMet'\" - AssessmentSubmittedWithGaps: - has-gaps: \"dm.ctx.overallResult !== 'FullyMet'\" Outcome: _always: - state-is-submitted: \"om.state.status.kind === 'Submitted'\" AssessmentSubmittedFullyMet: - result-recorded: \"om.state.status.overallResult === 'FullyMet'\" AssessmentSubmittedWithGaps: - gaps-recorded: \"om.state.gaps.length &gt; 0\" - result-recorded: \"om.state.status.overallResult !== 'FullyMet'\" # ── Batch: multiple unconditional events ── - When: RegisterLaboratory And: - valid-facility-ref: \"dm.ctx.facilityExists\" # shell: FacilityRegistry.lookup(dm.cmd.facilityRegistryId) - unique-facility-binding: \"!dm.ctx.facilityAlreadyBound\" # shell: LaboratoryRepo.findByFacility(dm.cmd.facilityRegistryId) - valid-name: \"dm.cmd.name.length &gt; 0\" Then: - LaboratoryRegistered - AuditTrailCreated Outcome: - state-is-planned: \"om.state.status.kind === 'Planned'\" - name-set: \"om.state.name === dm.cmd.name\" - facility-bound: \"om.state.facilityRegistryId === dm.cmd.facilityRegistryId\" - no-assignments: \"om.state.assignments.length === 0\" - two-events: \"om.evts.length === 2\" # ── Mixed: unconditional + conditional + conditional ── - When: RemoveCapability And: - registry-is-draft - capability-exists: \"dm.cmd.capabilityId in dm.state.capabilities\" - no-profile-refs: &gt; !Object.values(dm.state.profiles).some(p =&gt; p.requiredCapabilities.some(ref =&gt; ref.id === dm.cmd.capabilityId) || (p.allowedCapabilities ?? []).some(ref =&gt; ref.id === dm.cmd.capabilityId)) Then: - CapabilityRemoved - ChildCapabilitiesRemoved: - has-children: \"(dm.state.capabilities[dm.cmd.capabilityId].children ?? []).length &gt; 0\" Outcome: _always: - capability-gone: \"!(dm.cmd.capabilityId in om.state.capabilities)\" - test-entries-preserved: &gt; Object.keys(dm.state.testCatalog).every(id =&gt; id in om.state.testCatalog) ChildCapabilitiesRemoved: - children-gone: &gt; dm.state.capabilities[dm.cmd.capabilityId].children .every(child =&gt; !(child.id in om.state.capabilities)) . ",
    "url": "/spec/lifecycle.html#11-complete-example",
    
    "relUrl": "/spec/lifecycle.html#11-complete-example"
  },"65": {
    "doc": "Lifecycle UbiSpec",
    "title": "12. Grammar Summary",
    "content": "Document := Header Common? Lifecycle Header := 'bspec: lifecycle/v1' Decider Identity Model Common := 'common:' PredicateMap Lifecycle := 'lifecycle:' Decision+ Decision := When And? Then Outcome When := 'When:' CommandName And := 'And:' Constraint+ Constraint := PredicateEntry | CommonRef CommonRef := '- ' PredicateName Then := ScalarThen | ListThen ScalarThen := 'Then:' EventName ListThen := 'Then:' EventSpec+ EventSpec := UnconditionalEvent | ConditionalEvent UnconditionalEvent := '- ' EventName ConditionalEvent := '- ' EventName ':' PredicateEntry+ Outcome := FlatOutcome | KeyedOutcome FlatOutcome := 'Outcome:' PredicateEntry+ KeyedOutcome := 'Outcome:' AlwaysBlock? EventOutcome+ AlwaysBlock := '_always:' PredicateEntry+ EventOutcome := EventName ':' PredicateEntry+ PredicateEntry := '- ' PredicateName ':' Expression PredicateMap := (PredicateName ':' Expression)+ PredicateName := kebab-case-identifier Expression := TypeScript boolean expression over dm.* | om.* CommandName := PascalCase identifier EventName := PascalCase identifier . ",
    "url": "/spec/lifecycle.html#12-grammar-summary",
    
    "relUrl": "/spec/lifecycle.html#12-grammar-summary"
  },"66": {
    "doc": "Lifecycle UbiSpec",
    "title": "13. Versioning",
    "content": "Format: lifecycle/v1. Declared in the bspec header. Breaking changes increment the version. ",
    "url": "/spec/lifecycle.html#13-versioning",
    
    "relUrl": "/spec/lifecycle.html#13-versioning"
  },"67": {
    "doc": "Process UbiSpec",
    "title": "Process UbiSpec",
    "content": "Behavioural Specification Format for Cross-Aggregate Coordination . Version: 0.4.0 Part of: UbiSpec (Behavioural Specification Format for Software Systems) . ",
    "url": "/spec/process.html",
    
    "relUrl": "/spec/process.html"
  },"68": {
    "doc": "Process UbiSpec",
    "title": "1. Purpose",
    "content": "A Process UbiSpec describes the coordination logic between aggregates. It captures: . | Which events trigger cross-aggregate reactions | Under what conditions each reaction proceeds | Which commands are dispatched to which target deciders | What must be true about the commands produced | . A process manager sits between deciders. It subscribes to events from source deciders and dispatches commands to target deciders. It may be stateless (a reactor) or stateful (a saga). A Process UbiSpec only describes active reactions. If an event is observed and no conditions are met, no commands are dispatched — this is a valid no-op that does not need to be specified. ",
    "url": "/spec/process.html#1-purpose",
    
    "relUrl": "/spec/process.html#1-purpose"
  },"69": {
    "doc": "Process UbiSpec",
    "title": "2. Scope",
    "content": "One Process UbiSpec per process manager. A system may have zero or many process managers. Each coordinates between two or more aggregates whose lifecycles are described in Lifecycle UbiSpec. ",
    "url": "/spec/process.html#2-scope",
    
    "relUrl": "/spec/process.html#2-scope"
  },"70": {
    "doc": "Process UbiSpec",
    "title": "3. Relationship to Model and Lifecycle Specs",
    "content": "A Process UbiSpec references the same TypeScript model as the Lifecycle UbiSpec it coordinates. It also references the Lifecycle UbiSpec themselves — the event names in When must match events specified in the source decider’s lifecycle, and the command names in Then must match commands specified in the target decider’s lifecycle. This cross-reference is the contract boundary: the process manager is guaranteed to receive events with the shapes defined by the source decider, and must emit commands with the shapes expected by the target decider. ",
    "url": "/spec/process.html#3-relationship-to-model-and-lifecycle-specs",
    
    "relUrl": "/spec/process.html#3-relationship-to-model-and-lifecycle-specs"
  },"71": {
    "doc": "Process UbiSpec",
    "title": "4. Document Structure",
    "content": "bspec: process/v1 process: &lt;ProcessManagerName&gt; reacts_to: [&lt;DeciderName&gt;, ...] emits_to: [&lt;DeciderName&gt;, ...] model: &lt;path to TypeScript model file&gt; state: &lt;fieldName&gt;: &lt;TypeScript type&gt; common: &lt;predicate-name&gt;: &lt;expression&gt; reactions: - When: &lt;trigger&gt; From: &lt;source&gt; And: [...] Then: &lt;command specification&gt; Outcome: &lt;assertions&gt; . 4.1 Header . | Field | Required | Description | . | bspec | Yes | Format identifier. Must be process/v1. | . | process | Yes | Process manager name. PascalCase. | . | reacts_to | Yes | List of decider names whose events this process manager subscribes to. | . | emits_to | Yes | List of decider names to which this process manager dispatches commands. | . | model | Yes | Relative path to the TypeScript model file. | . The reacts_to and emits_to lists declare the topology — which aggregates this process manager connects. An agent can extract the full system wiring diagram from these declarations. 4.2 State . state: &lt;fieldName&gt;: &lt;TypeScript type&gt; . Optional. Only present for stateful sagas — process managers that need to track custom state beyond what When: { all: [...] } handles automatically. See §9 for when manual state is appropriate. When present, the state fields are available as rm.state in predicates and the reaction’s outcome can assert on om.state. 4.3 Common . Same as Lifecycle UbiSpec §4.2. Reusable predicates referenced by bare name. ",
    "url": "/spec/process.html#4-document-structure",
    
    "relUrl": "/spec/process.html#4-document-structure"
  },"72": {
    "doc": "Process UbiSpec",
    "title": "5. Reaction",
    "content": "Each element under reactions specifies the behaviour for one event-triggered reaction. reactions: - When: &lt;trigger&gt; From: &lt;source&gt; And: &lt;constraints&gt; Then: &lt;commands&gt; Outcome: &lt;assertions&gt; . 5.1 When + From — Trigger . Together, these identify the trigger: which event(s) from which decider(s) cause the reaction to fire. Three forms exist, addressing three distinct coordination patterns: . Scalar — Single Event . When: OrderPlaced From: Order . One event from one decider. The simplest form. The reaction fires once when this specific event occurs. Any — One of Several Events (OR) . When: any: [AssessmentSubmittedFullyMet, AssessmentSubmittedWithGaps] From: SelfAssessment . The reaction fires when any one of the listed events occurs. This is an OR — exactly one event fires, and the reaction runs once for that event. Rules: . | All listed events must come from the same decider (named in From). | All listed events must be defined in the source decider’s Lifecycle UbiSpec. | Each invocation receives exactly one event. rm.event is typed as the discriminated union of the listed events. Use rm.event.kind to distinguish variants (§7.1). | . Use any when multiple events represent variants of the same domain occurrence and the reaction logic is mostly identical, with small differences handled by conditional commands or event narrowing. All — Wait for Multiple Events (AND) . When: all: - PaymentConfirmed from Payment - InventoryReserved from Inventory correlate: orderId . The reaction fires only when all listed events have arrived for the same correlated instance. This is an AND — the runtime accumulates events until the set is complete, then fires the reaction once with all event payloads accessible. Rules: . | Events can come from different deciders. Each event is annotated with its source decider using the EventName from DeciderName syntax. | All listed deciders must appear in reacts_to. | All listed events must be defined in their respective source decider’s Lifecycle UbiSpec. | The correlate field declares which field links the events to the same instance. The named field must exist on every listed event. | From is not used. Source deciders are declared per-event. | Events may arrive in any order. The runtime handles accumulation. | When all events have arrived, each event payload is accessible by name: rm.events.PaymentConfirmed, rm.events.InventoryReserved (§7.1). There is no union — each event has its concrete type. | . Use all when multiple events must have occurred before the reaction can proceed — the scatter-gather or join pattern. When all events come from the same decider, the source can be written once: . When: all: [OrderPlaced, OrderApproved] From: Order correlate: orderId . This is equivalent to annotating each event with from Order. The From field is valid with all when all events share the same source. Summary . | Form | Syntax | Fires when | rm namespace | From | . | Scalar | When: EventName | Event occurs | rm.event (concrete) | Required | . | Any | When: { any: [...] } | Any one event occurs | rm.event (union) | Required (shared) | . | All | When: { all: [...] } + correlate | All events have arrived | rm.events.EventName (each concrete) | Per-event or shared | . 5.2 And — Constraints . And: - &lt;constraint-name&gt;: &lt;expression&gt; - &lt;constraint-name&gt; . Same semantics as Lifecycle UbiSpec §5.2. All constraints must hold for the reaction to proceed. If any fails, no commands are dispatched. For all triggers, constraints are evaluated after all events have arrived. The constraint predicates have access to every event payload via rm.events. Constraints are evaluated against the Reaction Model (§7). And is optional. A reaction with no constraints always proceeds. No implicit failure event. Unlike deciders, process managers do not emit DecisionFailed. A process manager that doesn’t react simply does nothing. The event was observed; no action was needed. This is by design — the source event is a fact that already happened, and the process manager’s silence is a valid outcome. 5.3 Then — Commands . Specifies which commands are dispatched on reaction. Each command is annotated with its target decider using -&gt; DeciderName. Scalar Form . Then: &lt;CommandName&gt; -&gt; &lt;DeciderName&gt; . Shorthand. Dispatches exactly one command, unconditionally. List Form . Then: - &lt;CommandName&gt; -&gt; &lt;DeciderName&gt; - &lt;CommandName&gt; -&gt; &lt;DeciderName&gt;: - &lt;condition-name&gt;: &lt;expression&gt; - &lt;CommandName&gt; -&gt; &lt;DeciderName&gt; . Each entry is a command that may or may not be dispatched: . | Unconditional command: bare CommandName -&gt; DeciderName. Always dispatched on reaction. | Conditional command: command with conditions. Dispatched only when all conditions hold. | . Rules: . | All qualifying commands are dispatched. Additive, same as Lifecycle UbiSpec events. | Commands are dispatched in list order. Order matters — a target decider may reject a command if a prior command hasn’t been processed first. | Conditions are evaluated against the Reaction Model (§7). | If all commands are conditional and none match, no commands are dispatched (valid no-op). | The -&gt; DeciderName must reference a decider in emits_to. | The CommandName must match a command in the target decider’s Lifecycle UbiSpec. | . Patterns . Single unconditional command: . Then: UpdateAssignment -&gt; Laboratory . Multiple unconditional commands (ordered sequence): . Then: - WithdrawAssignment -&gt; Laboratory - AssignProfile -&gt; Laboratory . Conditional command (only when conditions met): . Then: - WithdrawAssignment -&gt; Laboratory: - has-active-assignment: &gt; rm.ctx.laboratory.assignments.some(a =&gt; a.area.kind === rm.event.area.kind) . Mixed (base + conditional): . Then: - UpdateAssignment -&gt; Laboratory - NotifyCompliance -&gt; Notification: - is-regulated-area: \"rm.event.area.regulated === true\" . Multi-target (commands to different deciders): . Then: - ArchiveRegistry -&gt; Registry - TriggerReassessment -&gt; Laboratory . Event-discriminated with any (different commands for different triggering events): . When: any: [OrderPlaced, OrderConfirmed] From: Order Then: - ReserveInventory -&gt; Inventory: - is-placement: \"rm.event.kind === 'OrderPlaced'\" - ScheduleShipment -&gt; Fulfillment: - is-confirmation: \"rm.event.kind === 'OrderConfirmed'\" . Cross-event data assembly with all (combine data from both events): . When: all: - PaymentConfirmed from Payment - InventoryReserved from Inventory correlate: orderId Then: ScheduleShipment -&gt; Fulfillment Outcome: - uses-payment-data: &gt; om.commands.find(c =&gt; c.kind === 'ScheduleShipment') .amount === rm.events.PaymentConfirmed.amount - uses-inventory-data: &gt; om.commands.find(c =&gt; c.kind === 'ScheduleShipment') .lines === rm.events.InventoryReserved.reservedLines . 5.4 Outcome — Assertions . Specifies what must be true about the commands dispatched. Two forms: . Flat Form . Outcome: - &lt;assertion-name&gt;: &lt;expression&gt; . A flat list. All assertions must hold. Keyed Form . Outcome: _always: - &lt;assertion-name&gt;: &lt;expression&gt; &lt;CommandName&gt; -&gt; &lt;DeciderName&gt;: - &lt;assertion-name&gt;: &lt;expression&gt; . Assertions grouped by relevance: . | _always: assertions that hold for every reaction execution. | Command-keyed sections: assertions evaluated only when that command was dispatched. | . The key format is CommandName -&gt; DeciderName, matching the Then entries. All assertions use the Outcome Model (§8). ",
    "url": "/spec/process.html#5-reaction",
    
    "relUrl": "/spec/process.html#5-reaction"
  },"73": {
    "doc": "Process UbiSpec",
    "title": "6. Predicate Entry",
    "content": "Same as Lifecycle UbiSpec §6. All four detail levels apply — name only, scope annotation, prose description, and executable expression. Levels can be mixed within a single spec. For process manager predicates, scope annotations reference rm.* and om.* namespaces instead of dm.*: . # Level 1: name only - has-active-assignment # Level 2: scope annotation - has-active-assignment: rm.ctx - correct-amount: [rm.events.PaymentConfirmed, om.commands] # Level 3: prose - has-active-assignment: \"Target laboratory has an active assignment in this area (rm.ctx)\" # Level 4: executable - has-active-assignment: \"rm.ctx.laboratory.assignments.some(a =&gt; a.area.kind === rm.event.area.kind)\" . ",
    "url": "/spec/process.html#6-predicate-entry",
    
    "relUrl": "/spec/process.html#6-predicate-entry"
  },"74": {
    "doc": "Process UbiSpec",
    "title": "7. Reaction Model (rm)",
    "content": "The input context for process manager constraints and command conditions. 7.1 rm.event / rm.events — Triggering Events . The namespace depends on the When form: . Scalar and Any — rm.event (singular) . For scalar and any triggers, the reaction receives exactly one event. rm.event is a concrete runtime value — an object with a kind field and payload fields. Scalar When — rm.event is that event’s type, directly accessible: . When: AssessmentConfirmed From: SelfAssessment # rm.event is an AssessmentConfirmed — all fields directly accessible And: - has-reviewer: \"rm.event.reviewedBy.length &gt; 0\" . Any When — rm.event is a discriminated union. Use rm.event.kind to narrow: . When: any: [AssessmentSubmittedFullyMet, AssessmentSubmittedWithGaps] From: SelfAssessment # rm.event is one of the two types — narrow with .kind Then: - UpdateAssignment -&gt; Laboratory - ForwardGaps -&gt; Laboratory: - has-gaps: \"rm.event.kind === 'AssessmentSubmittedWithGaps'\" . Narrowing rules for any: . Fields common to all events in the union can be accessed directly without narrowing (e.g., rm.event.laboratoryId if all events carry it). Variant-specific fields require narrowing: . Inline narrowing with &amp;&amp; (preferred): TypeScript narrows within a single &amp;&amp; expression. Safe at runtime — short-circuit prevents invalid access: . - has-gaps: \"rm.event.kind === 'AssessmentSubmittedWithGaps' &amp;&amp; rm.event.gaps.length &gt; 0\" . Conditional structure as narrowing context: A conditional command’s conditions establish which variant is present. Outcome assertions under that command’s key inherit the narrowing: . Then: - ForwardGaps -&gt; Laboratory: - has-gaps: \"rm.event.kind === 'AssessmentSubmittedWithGaps'\" Outcome: ForwardGaps -&gt; Laboratory: # Only evaluated when ForwardGaps dispatched → rm.event.kind is 'AssessmentSubmittedWithGaps' - gaps-forwarded: \"om.commands.find(c =&gt; c.kind === 'ForwardGaps').gaps === rm.event.gaps\" . Optional chaining as fallback: . - gaps-if-present: \"rm.event.gaps?.length ?? 0 &gt; 0\" . All — rm.events (plural, keyed by event name) . For all triggers, every event payload is accessible by its event name. Each is its own concrete type — no union, no narrowing needed: . When: all: - PaymentConfirmed from Payment - InventoryReserved from Inventory correlate: orderId And: - both-approved: &gt; rm.events.PaymentConfirmed.status === 'captured' &amp;&amp; rm.events.InventoryReserved.status === 'reserved' Then: ScheduleShipment -&gt; Fulfillment Outcome: - correct-amount: &gt; om.commands.find(c =&gt; c.kind === 'ScheduleShipment') .amount === rm.events.PaymentConfirmed.amount - correct-lines: &gt; om.commands.find(c =&gt; c.kind === 'ScheduleShipment') .lines === rm.events.InventoryReserved.reservedLines - same-order: &gt; rm.events.PaymentConfirmed.orderId === rm.events.InventoryReserved.orderId . Rules: . | rm.events.&lt;EventName&gt; is the concrete event type — no discrimination needed. | Every event listed in all is guaranteed present when the reaction fires. | The field name matches the event name exactly as declared in the all list. | rm.event (singular) is not available in all reactions. Use rm.events. | . Summary . | When form | Namespace | Type | Narrowing needed | . | Scalar | rm.event | Concrete event type | No | . | Any | rm.event | Discriminated union | Yes (.kind) | . | All | rm.events.EventName | Each concrete type | No | . 7.2 rm.state — Process Manager State . Only for stateful sagas. The process manager’s own state before the reaction. - not-already-tracking: \"!(rm.event.registryId in rm.state.pendingReassessments)\" . Stateless reactors and reactions using When: { all: [...] } without custom state do not reference rm.state. The all trigger handles event accumulation automatically — the spec author does not need to manage saga state for the join pattern. 7.3 rm.ctx — Shell-Resolved Context . Async context resolved before the reaction runs. Typically read-model queries — looking up the current state of target aggregates. - has-assignment: &gt; rm.ctx.laboratory.assignments.some(a =&gt; a.area.kind === rm.event.area.kind) # shell: LaboratoryReadModel.findById(rm.event.laboratoryId) - adjusted-profile-exists: \"rm.ctx.adjustedProfileExists\" # shell: RegistryReadModel.profileExists(rm.event.adjustedProfileId) . Convention: annotate with # shell: &lt;resolution hint&gt;. Note: rm.ctx queries target read models, which are eventually consistent. The spec should be written with this in mind — a reaction that depends on split-second consistency should be flagged. For all triggers, shell expressions can reference any event payload via rm.events: . - current-stock: \"rm.ctx.availableStock &gt;= rm.events.OrderPlaced.requestedQuantity\" # shell: InventoryReadModel.getStock(rm.events.OrderPlaced.productId) . 7.4 Derivations . An agent scans the specification to derive: . | Context type per reaction: TypeScript type from rm.ctx.* paths. | Shell function per reaction: async function that resolves the context. | Event type for scalar/any: concrete type or discriminated union for rm.event. | Event record type for all: { PaymentConfirmed: PaymentConfirmedEvent; InventoryReserved: InventoryReservedEvent } for rm.events. | Correlation key: from correlate field, verified present on all events. | Contract verification: rm.event / rm.events field paths checked against source decider event types. Command payloads checked against target decider command types. | . ",
    "url": "/spec/process.html#7-reaction-model-rm",
    
    "relUrl": "/spec/process.html#7-reaction-model-rm"
  },"75": {
    "doc": "Process UbiSpec",
    "title": "8. Outcome Model (om)",
    "content": "The context for postcondition assertions. 8.1 om.commands — Dispatched Commands . The ordered list of commands to be dispatched. Each command has a kind field (the command name) and payload fields matching the target decider’s command type. - review-triggered: &gt; om.commands.some(c =&gt; c.kind === 'UpdateAssignment' &amp;&amp; c.targetKind === 'UnderReview' &amp;&amp; c.laboratoryId === rm.event.laboratoryId) - correct-count: \"om.commands.length === 2\" - correct-order: &gt; om.commands.findIndex(c =&gt; c.kind === 'WithdrawAssignment') &lt; om.commands.findIndex(c =&gt; c.kind === 'AssignProfile') . 8.2 om.state — Process Manager State After . Only for stateful sagas with custom state. The process manager’s state after the reaction. - reassessments-tracked: &gt; om.state.pendingReassessments[rm.event.registryId]?.length === rm.ctx.affectedLaboratories.length . 8.3 Cross-Model Access . | Namespace | Available in | Purpose | . | om.commands | All reactions | Commands dispatched — what will happen | . | om.state | Stateful sagas | New PM state | . | rm.event | Scalar, Any | Triggering event — data flow verification | . | rm.events | All | All triggering events — data flow verification | . | rm.state | Stateful sagas | Old PM state — before/after comparison | . | rm.ctx | All reactions | Resolved context — cross-referencing | . 8.4 Outcome Completeness . A thorough Outcome includes: . | Command presence — correct commands dispatched to correct targets | Command payload — data flows correctly from events to commands | Command ordering — sequence matters when target decider has dependencies | Command count — no unexpected extra commands | Correlation integrity (for all) — all events reference the same instance | State tracking (sagas) — correlation state updated correctly | . ",
    "url": "/spec/process.html#8-outcome-model-om",
    
    "relUrl": "/spec/process.html#8-outcome-model-om"
  },"76": {
    "doc": "Process UbiSpec",
    "title": "9. Stateless vs Stateful",
    "content": "9.1 Stateless Reactor . Most process managers are stateless. They receive an event (or a completed set of events for all), optionally query context, and emit commands. No state section. No rm.state or om.state references. bspec: process/v1 process: AssessmentLifecycleManager reacts_to: [SelfAssessment] emits_to: [Laboratory] model: \"./model.ts\" reactions: - When: AssessmentConfirmed From: SelfAssessment Then: UpdateAssignment -&gt; Laboratory Outcome: - confirmed: &gt; om.commands.some(c =&gt; c.kind === 'UpdateAssignment' &amp;&amp; c.targetKind === 'Confirmed') . Note: When: { all: [...] } reactions are also stateless from the spec author’s perspective. The runtime manages event accumulation. The spec describes what happens when all events are present — not how to accumulate them. 9.2 Stateful Saga . When a process manager needs custom state beyond what all provides — for example, tracking a dynamic set of expected events, implementing timeouts, or managing multi-step compensation — it declares a state section and uses rm.state/om.state. bspec: process/v1 process: RegistryVersionManager reacts_to: [Registry, Laboratory] emits_to: [Laboratory] model: \"./model.ts\" state: pendingReassessments: \"Record&lt;string, string[]&gt;\" # registryId -&gt; labIds reactions: - When: RegistryArchived From: Registry And: - has-affected-labs: \"rm.ctx.affectedLaboratories.length &gt; 0\" Then: TriggerReassessment -&gt; Laboratory Outcome: - reassessments-tracked: &gt; om.state.pendingReassessments[rm.event.registryId]?.length === rm.ctx.affectedLaboratories.length - When: AssignmentReassessmentTriggered From: Laboratory And: - is-tracked: \"rm.event.registryId in rm.state.pendingReassessments\" Then: - CompleteReassessmentCycle -&gt; Registry: - all-done: &gt; rm.state.pendingReassessments[rm.event.registryId] .filter(id =&gt; id !== rm.event.laboratoryId).length === 0 Outcome: CompleteReassessmentCycle -&gt; Registry: - tracking-cleared: &gt; !(rm.event.registryId in om.state.pendingReassessments) . 9.3 Choosing . | Need | Solution | . | React to one event | Scalar When (stateless) | . | React to one of several events | When: { any: [...] } (stateless) | . | Wait for a known set of events | When: { all: [...] } (stateless) | . | Track a dynamic set of events | Custom state section (stateful saga) | . | Implement timeouts or deadlines | Custom state section (stateful saga) | . | Multi-step compensation | Custom state section (stateful saga) | . Prefer stateless. Use all before reaching for manual state. Only go stateful when the coordination logic cannot be expressed as a fixed set of awaited events. ",
    "url": "/spec/process.html#9-stateless-vs-stateful",
    
    "relUrl": "/spec/process.html#9-stateless-vs-stateful"
  },"77": {
    "doc": "Process UbiSpec",
    "title": "10. Interpretation",
    "content": "10.1 As a Wiring Diagram . The reacts_to and emits_to headers, combined with When/From and Then -&gt; Target, define the full event-command topology of the system: . DeciderA --[EventX]--&gt; ProcessManager --[CommandY]--&gt; DeciderB --[CommandZ]--&gt; DeciderC . For all triggers, the diagram shows multiple inbound arrows converging: . Payment --[PaymentConfirmed]---\\ --&gt; ReadyToShipManager --[ScheduleShipment]--&gt; Fulfillment Inventory --[InventoryReserved]--/ . An agent can extract the full topology from all Process UbiSpec and Lifecycle UbiSpec in the system. 10.2 As Test Cases . Each reaction generates: . | Happy path: given event(s) and context satisfying all constraints, assert correct commands dispatched with correct payloads and ordering. | Per-constraint no-op: for each constraint, given a violation, assert no commands dispatched. | Conditional command coverage: for each conditional command, test with conditions met and not met. | any trigger coverage: for each event variant, test separately. | all arrival order coverage: test all permutations of event arrival order. | all correlation: verify events with different correlation values are handled independently. | Contract verification: command payloads type-check against target decider’s command types. | Ordering tests: when ordering assertions exist, verify sequence. | Saga state (if stateful): given events in sequence, verify state accumulation. | . 10.3 As Implementation Contract . | react function: translates constraints and command conditions into code. | Shell function: derived from rm.ctx references. | Event subscription: derived from When + From. any subscribes to multiple events. all sets up accumulation with correlation. | Event types: concrete for scalar, discriminated union for any, record for all. | Correlation: from correlate field, verified present on all events in all. | Contract types: event types from source deciders, command types for target deciders. | Saga state machine (if stateful): state transitions derived from reactions. | . ",
    "url": "/spec/process.html#10-interpretation",
    
    "relUrl": "/spec/process.html#10-interpretation"
  },"78": {
    "doc": "Process UbiSpec",
    "title": "11. Complete Examples",
    "content": "11.1 Stateless Reactor with any Trigger . bspec: process/v1 process: AssessmentLifecycleManager reacts_to: [SelfAssessment] emits_to: [Laboratory] model: \"./model.ts\" reactions: # ── any: two events, same core reaction ── - When: any: [AssessmentSubmittedFullyMet, AssessmentSubmittedWithGaps] From: SelfAssessment Then: - UpdateAssignment -&gt; Laboratory - ForwardGaps -&gt; Laboratory: - has-gaps: \"rm.event.kind === 'AssessmentSubmittedWithGaps'\" Outcome: _always: - review-triggered: &gt; om.commands.some(c =&gt; c.kind === 'UpdateAssignment' &amp;&amp; c.targetKind === 'UnderReview' &amp;&amp; c.laboratoryId === rm.event.laboratoryId) ForwardGaps -&gt; Laboratory: - gaps-forwarded: &gt; om.commands.find(c =&gt; c.kind === 'ForwardGaps') .gaps === rm.event.gaps # ── Scalar: one event, one command ── - When: AssessmentConfirmed From: SelfAssessment Then: UpdateAssignment -&gt; Laboratory Outcome: - assignment-confirmed: &gt; om.commands.some(c =&gt; c.kind === 'UpdateAssignment' &amp;&amp; c.targetKind === 'Confirmed' &amp;&amp; c.confirmedBy === rm.event.reviewedBy) # ── Ordered sequence ── - When: AssessmentAdjusted From: SelfAssessment And: - adjusted-profile-exists: \"rm.ctx.adjustedProfileExists\" Then: - WithdrawAssignment -&gt; Laboratory - AssignProfile -&gt; Laboratory Outcome: - old-withdrawn: &gt; om.commands.some(c =&gt; c.kind === 'WithdrawAssignment' &amp;&amp; c.area.kind === rm.event.area.kind) - new-assigned: &gt; om.commands.some(c =&gt; c.kind === 'AssignProfile' &amp;&amp; c.profileId === rm.event.adjustedProfileId &amp;&amp; c.source === 'authority') - correct-order: &gt; om.commands.findIndex(c =&gt; c.kind === 'WithdrawAssignment') &lt; om.commands.findIndex(c =&gt; c.kind === 'AssignProfile') - When: AssessmentDevelopmentPlanIssued From: SelfAssessment Then: UpdateAssignment -&gt; Laboratory Outcome: - development-plan-set: &gt; om.commands.some(c =&gt; c.kind === 'UpdateAssignment' &amp;&amp; c.targetKind === 'Development' &amp;&amp; c.actions === rm.event.actions) - When: RevisionRequested From: SelfAssessment Then: UpdateAssignment -&gt; Laboratory Outcome: - assignment-reverted: &gt; om.commands.some(c =&gt; c.kind === 'UpdateAssignment' &amp;&amp; c.targetKind === 'SelfAssessed') # ── Conditional command ── - When: AssessmentCancelled From: SelfAssessment Then: - WithdrawAssignment -&gt; Laboratory: - has-active-assignment: &gt; rm.ctx.laboratory.assignments.some(a =&gt; a.area.kind === rm.event.area.kind &amp;&amp; (a.kind === 'SelfAssessed' || a.kind === 'UnderReview')) Outcome: WithdrawAssignment -&gt; Laboratory: - correct-area: &gt; om.commands.find(c =&gt; c.kind === 'WithdrawAssignment') .area.kind === rm.event.area.kind . 11.2 Cross-Aggregate Join with all Trigger . bspec: process/v1 process: ReadyToShipManager reacts_to: [Payment, Inventory] emits_to: [Fulfillment] model: \"./model.ts\" reactions: - When: all: - PaymentConfirmed from Payment - InventoryReserved from Inventory correlate: orderId Then: ScheduleShipment -&gt; Fulfillment Outcome: - shipment-for-correct-order: &gt; om.commands.find(c =&gt; c.kind === 'ScheduleShipment') .orderId === rm.events.PaymentConfirmed.orderId - uses-payment-amount: &gt; om.commands.find(c =&gt; c.kind === 'ScheduleShipment') .amount === rm.events.PaymentConfirmed.capturedAmount - uses-reserved-lines: &gt; om.commands.find(c =&gt; c.kind === 'ScheduleShipment') .lines.length === rm.events.InventoryReserved.reservedLines.length - single-command: \"om.commands.length === 1\" . 11.3 Same-Decider Join with all Trigger . bspec: process/v1 process: OrderReadyForProcessingManager reacts_to: [Order] emits_to: [Fulfillment] model: \"./model.ts\" reactions: - When: all: [OrderPlaced, PaymentVerified] From: Order correlate: orderId And: - no-fraud-flag: \"rm.events.PaymentVerified.fraudScore &lt; 0.7\" Then: BeginFulfillment -&gt; Fulfillment Outcome: - fulfillment-initiated: &gt; om.commands.some(c =&gt; c.kind === 'BeginFulfillment' &amp;&amp; c.orderId === rm.events.OrderPlaced.orderId &amp;&amp; c.lines === rm.events.OrderPlaced.lines) . ",
    "url": "/spec/process.html#11-complete-examples",
    
    "relUrl": "/spec/process.html#11-complete-examples"
  },"79": {
    "doc": "Process UbiSpec",
    "title": "12. Grammar Summary",
    "content": "Document := Header State? Common? Reactions Header := 'bspec: process/v1' Process ReactsTo EmitsTo Model Process := 'process:' ProcessName ReactsTo := 'reacts_to:' '[' DeciderName (',' DeciderName)* ']' EmitsTo := 'emits_to:' '[' DeciderName (',' DeciderName)* ']' State := 'state:' FieldMap Common := 'common:' PredicateMap Reactions := 'reactions:' Reaction+ Reaction := Trigger And? Then Outcome Trigger := ScalarTrigger | AnyTrigger | AllTrigger ScalarTrigger := 'When:' EventName 'From:' DeciderName AnyTrigger := 'When:' '{' 'any:' EventList '}' 'From:' DeciderName AllTrigger := AllTriggerCross | AllTriggerShared AllTriggerCross := 'When:' '{' 'all:' SourcedEventList '}' 'correlate:' FieldName AllTriggerShared := 'When:' '{' 'all:' EventList '}' 'From:' DeciderName 'correlate:' FieldName EventList := '[' EventName (',' EventName)+ ']' SourcedEventList := SourcedEvent+ SourcedEvent := '- ' EventName ' from ' DeciderName And := 'And:' Constraint+ Constraint := PredicateEntry | CommonRef Then := ScalarThen | ListThen ScalarThen := 'Then:' TargetedCommand ListThen := 'Then:' CommandSpec+ CommandSpec := UnconditionalCommand | ConditionalCommand UnconditionalCommand := '- ' TargetedCommand ConditionalCommand := '- ' TargetedCommand ':' PredicateEntry+ TargetedCommand := CommandName ' -&gt; ' DeciderName Outcome := FlatOutcome | KeyedOutcome FlatOutcome := 'Outcome:' PredicateEntry+ KeyedOutcome := 'Outcome:' AlwaysBlock? CommandOutcome+ AlwaysBlock := '_always:' PredicateEntry+ CommandOutcome := TargetedCommand ':' PredicateEntry+ PredicateEntry := '- ' PredicateName ':' Expression PredicateMap := (PredicateName ':' Expression)+ FieldMap := (FieldName ':' TypeExpression)+ PredicateName := kebab-case-identifier Expression := TypeScript boolean expression over rm.* | om.* ProcessName := PascalCase identifier DeciderName := PascalCase identifier EventName := PascalCase identifier CommandName := PascalCase identifier FieldName := camelCase identifier . ",
    "url": "/spec/process.html#12-grammar-summary",
    
    "relUrl": "/spec/process.html#12-grammar-summary"
  },"80": {
    "doc": "Process UbiSpec",
    "title": "13. Comparison with Lifecycle UbiSpec",
    "content": "| Concept | Lifecycle UbiSpec | Process UbiSpec | . | Triggered by | Command (When) | Event(s) (When + From) | . | Produces | Events (Then) | Commands (Then + -&gt; Target) | . | Input model | dm (cmd, state, ctx) | rm (event/events, state, ctx) | . | Output model | om (state, evts) | om (commands, state) | . | Failure | DecisionFailed event | No-op (silence) | . | State | Always (aggregate) | Optional (saga) | . | Identity | Aggregate ID | Correlation (from events) | . | Topology | Self-contained | Declares reacts_to / emits_to | . | Single trigger | One command | Scalar: one event | . | OR trigger | N/A | any: one of several events | . | AND trigger | N/A | all: wait for all events + correlate | . ",
    "url": "/spec/process.html#13-comparison-with-lifecycle-ubispec",
    
    "relUrl": "/spec/process.html#13-comparison-with-lifecycle-ubispec"
  },"81": {
    "doc": "Process UbiSpec",
    "title": "14. Versioning",
    "content": "Format: process/v1. Declared in the bspec header. Breaking changes increment the version. ",
    "url": "/spec/process.html#14-versioning",
    
    "relUrl": "/spec/process.html#14-versioning"
  }
}
